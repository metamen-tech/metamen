# ══════════════════════════════════════════════════════════════

# CAJA_3_VFULL v2.0.0 — BACKEND: DATABASE + FUNCTIONS + RLS + TYPES + SERVER ACTIONS + MIGRATIONS + INTEGRATIONS

# Alineado a: Constantes Maestras v2.0.0 · PRD v2.0.0 · ADRs v2.0.0 · Tech Spec v2.0.0

# ══════════════════════════════════════════════════════════════

---

# ══════════════════════════════════════════════════════════════

# SUBCAJA 03.1 — SCHEMA DDL

# Extensiones · ENUMs · Tablas · Índices · Triggers · Constraints

# 54 TAREAS

# ══════════════════════════════════════════════════════════════

---

## 03.1.1 — EXTENSIONES Y CONFIGURACIÓN BASE

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.1.1.1 | Habilitar extensión `uuid-ossp` | [SQL] | `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";` — Requerida para generación de UUIDs v4 en todas las tablas del sistema. | `SELECT * FROM pg_extension WHERE extname = 'uuid-ossp';` devuelve 1 fila. |
| 03.1.1.2 | Habilitar extensión `pgcrypto` | [SQL] | `CREATE EXTENSION IF NOT EXISTS "pgcrypto";` — Requerida para funciones criptográficas, generación segura de tokens y encriptación AES-256 de teléfonos. | `SELECT * FROM pg_extension WHERE extname = 'pgcrypto';` devuelve 1 fila. |
| 03.1.1.3 | Habilitar extensión `pg_trgm` | [SQL] | `CREATE EXTENSION IF NOT EXISTS "pg_trgm";` — Requerida para búsquedas fuzzy en catálogo de tienda (store_[items.name](http://items.name)) y nicknames. | `SELECT * FROM pg_extension WHERE extname = 'pg_trgm';` devuelve 1 fila. |
| 03.1.1.4 | Configurar timezone del servidor | [SQL] | `ALTER DATABASE postgres SET timezone TO 'UTC';` — Todas las operaciones temporales en UTC. Conversión a timezone del usuario exclusivamente en capa de aplicación (Server Actions). **Constantes Maestras §5.12**: timezone cooldown 30 días entre cambios. | `SHOW timezone;` devuelve `UTC`. |

---

## 03.1.2 — TIPOS ENUM

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.1.2.1 | Crear ENUM `task_status_enum` | [SQL] | `CREATE TYPE public.task_status_enum AS ENUM ('pending', 'in_progress', 'completed', 'failed');` — **4 estados** de tarea. **Constantes Maestras §5.7 + ADRs §4.1**: pending (sin iniciar), in_progress (herramienta en curso), completed (terminada con éxito), failed (no completada al cierre del día). | `SELECT enum_range(NULL::task_status_enum);` devuelve 4 valores. |
| 03.1.2.2 | Crear ENUM `day_status_enum` | [SQL] | `CREATE TYPE public.day_status_enum AS ENUM ('success', 'failed', 'death');` — **3 estados** de resultado del Judgement Night. **Constantes Maestras §5.4**: success = ≥80% completado (+1 HP, streak continúa), failed = <80% (−1 HP, streak=0), death = HP llegó a 0 durante evaluación. | `SELECT enum_range(NULL::day_status_enum);` devuelve 3 valores. |
| 03.1.2.3 | Crear ENUM `subscription_status_enum` | [SQL] | `CREATE TYPE public.subscription_status_enum AS ENUM ('trial', 'active', 'limbo', 'cancelled');` — **Constantes Maestras §1**: trial (5 días gratis, sin tarjeta), active (suscripción pagada vigente), limbo (pago fallido, 7 días read-only), cancelled (acceso revocado). | `SELECT enum_range(NULL::subscription_status_enum);` devuelve 4 valores. |
| 03.1.2.4 | Crear ENUM `task_category_enum` (17 categorías) | [SQL] | `CREATE TYPE public.task_category_enum AS ENUM ('meditation', 'thanks', 'posture', 'wake_early', 'facial', 'voice', 'cold_shower', 'skill_learning', 'focus_work', 'reading', 'strength', 'cardio', 'hydration', 'talk_friend', 'family', 'kegel', 'journal');` — **Constantes Maestras §5.5**: 17 categorías mapeadas a 5 vectores principales. AURA(4): meditation, thanks, posture, wake_early. JAWLINE(3): facial, voice, cold_shower. WEALTH(3): skill_learning, focus_work, reading. PHYSIQUE(3): strength, cardio, hydration. SOCIAL(4): talk_friend, family, kegel, journal. | `SELECT enum_range(NULL::task_category_enum);` devuelve exactamente 17 valores. Verificar cada uno por nombre contra Constantes §5.5. |
| 03.1.2.5 | Crear ENUM `task_archetype_enum` (5 arquetipos) | [SQL] | `CREATE TYPE public.task_archetype_enum AS ENUM ('MENTAL', 'FACIAL', 'ECONOMIC', 'PHYSICAL', 'SOCIAL');` — **Constantes Maestras §5.1**: 5 arquetipos mapeados 1:1 con los 5 vectores principales. MENTAL→AURA, FACIAL→JAWLINE, ECONOMIC→WEALTH, PHYSICAL→PHYSIQUE, SOCIAL→SOCIAL. ENV no tiene arquetipo directo (se modifica vía items de tienda tipo upgrade). | `SELECT enum_range(NULL::task_archetype_enum);` devuelve 5 valores. |
| 03.1.2.6 | Crear ENUM `tool_type_enum` (9 herramientas) | [SQL] | `CREATE TYPE public.tool_type_enum AS ENUM ('meditation', 'focus_timer', 'lookmaxing', 'journal', 'logbook', 'kegel', 'posture', 'metagym', 'voice');` — **Constantes Maestras §5.9**: Arsenal de 9 herramientas. meditation=Cámara de Meditación, focus_timer=Focus Chamber, lookmaxing=Escultor Facial, journal=Bitácora de Guerra, logbook=Biblioteca de Poder, kegel=Vitalidad Sexual, posture=Movilidad Táctica, metagym=Templo del Hierro, voice=Comando de Voz. | `SELECT enum_range(NULL::tool_type_enum);` devuelve exactamente 9 valores. |
| 03.1.2.7 | Crear ENUM `item_rarity_enum` (4 niveles) | [SQL] | `CREATE TYPE public.item_rarity_enum AS ENUM ('common', 'rare', 'epic', 'legendary');` — **Constantes Maestras §2.7**: 4 rarezas. common=#95A5A6, rare=#3498DB, epic=#9B59B6, legendary=#D4AF37 (con glow). **CAMBIO v2.0**: eliminado 'uncommon' que existía en versión anterior. | `SELECT enum_range(NULL::item_rarity_enum);` devuelve 4 valores. Verificar que NO existe 'uncommon'. |
| 03.1.2.8 | Crear ENUM `item_slot_enum` | [SQL] | `CREATE TYPE public.item_slot_enum AS ENUM ('head', 'face', 'body', 'hands', 'legs', 'feet', 'accessory');` — 7 slots de equipamiento del avatar según PRD US-STORE-001 (cabeza, torso, piernas, pies, accesorios) + face + hands. | `SELECT enum_range(NULL::item_slot_enum);` devuelve 7 valores. |
| 03.1.2.9 | Crear ENUM `item_category_enum` | [SQL] | `CREATE TYPE public.item_category_enum AS ENUM ('armor', 'accessories', 'vehicles', 'properties', 'companions', 'pets', 'powerups');` — Categorías de items de tienda. 'properties' afecta ENV (upgrade de entorno). | `SELECT enum_range(NULL::item_category_enum);` devuelve 7 valores. |
| 03.1.2.10 | Crear ENUM `image_gen_status_enum` | [SQL] | `CREATE TYPE public.image_gen_status_enum AS ENUM ('pending', 'processing', 'completed', 'failed', 'retrying');` — **ADRs §4.1**: 5 estados de la cola de generación de imágenes. 'retrying' añadido para tracking de reintentos Gemini. | `SELECT enum_range(NULL::image_gen_status_enum);` devuelve 5 valores. |
| 03.1.2.11 | Crear ENUM `notification_type_enum` | [SQL] | `CREATE TYPE public.notification_type_enum AS ENUM ('task_completed', 'level_up', 'streak_milestone', 'health_warning', 'health_critical', 'avatar_died', 'image_ready', 'trial_expiring', 'payment_failed', 'general');` — **ADRs §4.1**: 10 tipos de notificación del sistema actualizados v2.0. | `SELECT enum_range(NULL::notification_type_enum);` devuelve 10 valores. |
| 03.1.2.12 | Crear ENUM `payment_status_enum` | [SQL] | `CREATE TYPE public.payment_status_enum AS ENUM ('pending', 'completed', 'failed', 'refunded');` — Estados de pago Stripe. | `SELECT enum_range(NULL::payment_status_enum);` devuelve 4 valores. |

---

## 03.1.3 — TABLAS PRINCIPALES (13 tablas)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.1.3.1 | Crear tabla `profiles` | [SQL] | Tabla de perfiles de usuario. Campos: `id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE`, `email TEXT NOT NULL`, `nickname TEXT NOT NULL` — **PRD US-AUTH-001**: formato 'METAMEN-XXXX' generado por secuencia, `display_name TEXT`, `phone_encrypted TEXT` — **PRD US-AUTH-003**: AES-256, constraint UNIQUE, `base_avatar_id SMALLINT NOT NULL DEFAULT 1 CHECK (base_avatar_id BETWEEN 1 AND 6)` — **Constantes §5.2**: 6 personajes (1=EL_RASTAS, 2=EL_GUARRO, 3=EL_PECAS, 4=EL_GREÑAS, 5=EL_GUERO, 6=EL_LIC), `onboarding_completed BOOLEAN DEFAULT FALSE`, `oath_taken BOOLEAN DEFAULT FALSE` — **PRD US-ONB-005**, `timezone TEXT DEFAULT 'America/Mexico_City'`, `timezone_changed_at TIMESTAMPTZ` — **Constantes §5.12**: cooldown 30 días, `judgement_hour SMALLINT DEFAULT 0 CHECK (judgement_hour BETWEEN 0 AND 23)`, `locale TEXT DEFAULT 'es-MX'`, `deleted_at TIMESTAMPTZ` — **PRD US-PROF-004**: soft delete, `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`. Secuencia auxiliar: `CREATE SEQUENCE IF NOT EXISTS nickname_seq START 1;`. | Tabla existe con 14 columnas. `base_avatar_id` acepta 1-6, rechaza 0 y 7. FK a auth.users funciona. nickname se genera automáticamente vía trigger. |
| 03.1.3.2 | Crear tabla `avatar_states` | [SQL] | Estado del avatar con **6 vectores + HP + level + estado**. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL UNIQUE REFERENCES profiles(id) ON DELETE CASCADE`, `aura_lvl NUMERIC(5,2) DEFAULT 0.00 CHECK (aura_lvl BETWEEN 0.00 AND 50.00)`, `jawline_lvl NUMERIC(5,2) DEFAULT 0.00 CHECK (jawline_lvl BETWEEN 0.00 AND 50.00)`, `wealth_lvl NUMERIC(5,2) DEFAULT 0.00 CHECK (wealth_lvl BETWEEN 0.00 AND 50.00)`, `physique_lvl NUMERIC(5,2) DEFAULT 0.00 CHECK (physique_lvl BETWEEN 0.00 AND 50.00)`, `social_lvl NUMERIC(5,2) DEFAULT 0.00 CHECK (social_lvl BETWEEN 0.00 AND 50.00)`, `env_lvl SMALLINT DEFAULT 1 CHECK (env_lvl BETWEEN 1 AND 10)`, `overall_score NUMERIC(5,2) DEFAULT 0.00 CHECK (overall_score BETWEEN 0.00 AND 50.00)`, `health_points SMALLINT DEFAULT 5 CHECK (health_points BETWEEN 0 AND 14)` — **Constantes §5.4**: inicio 5, máx expandido 14, `max_health_points SMALLINT DEFAULT 10 CHECK (max_health_points BETWEEN 10 AND 14)` — **CAMBIO v2.0**: máximo expandido 14 (no 13), `current_level SMALLINT DEFAULT 1 CHECK (current_level BETWEEN 1 AND 12)` — **CAMBIO v2.0**: 12 niveles (no 13), `current_day SMALLINT DEFAULT 0`, `streak_days SMALLINT DEFAULT 0`, `death_count SMALLINT DEFAULT 0`, `is_hibernated BOOLEAN DEFAULT FALSE` — **Constantes §5.6**: hibernación tras 3ª+ muerte, `last_image_url TEXT`, `image_version INTEGER DEFAULT 0`, `version INTEGER DEFAULT 1` — optimistic locking per ADR, `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`. | Tabla existe con 20 columnas. Vectores aceptan 0.00-50.00, rechazan -1 y 51. env_lvl acepta 1-10. health_points DEFAULT 5, max 14. current_level max 12. Constraint UNIQUE en user_id. |
| 03.1.3.3 | Crear tabla `wallets` | [SQL] | Wallet de BTC virtual. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL UNIQUE REFERENCES profiles(id) ON DELETE CASCADE`, `btc_balance INTEGER DEFAULT 0 CHECK (btc_balance >= 0)` — **CAMBIO v2.0**: renombrado de 'balance' a 'btc_balance' per ADRs §4.2, `total_earned INTEGER DEFAULT 0`, `total_spent INTEGER DEFAULT 0`, `today_earned INTEGER DEFAULT 0` — se resetea cada día por cron, `daily_cap INTEGER DEFAULT 2000` — **CAMBIO v2.0**: de 3,500 a **2,000** BTC/día per Constantes §5.6, `version INTEGER DEFAULT 1`, `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`. | Tabla existe. `daily_cap` DEFAULT es **2000**. btc_balance no acepta negativos. Verificar que NO es 3500. |
| 03.1.3.4 | Crear tabla `subscriptions` | [SQL] | Estado de suscripción. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL UNIQUE REFERENCES profiles(id) ON DELETE CASCADE`, `status subscription_status_enum DEFAULT 'trial'`, `plan TEXT` — **Constantes §1**: 'weekly' ($2.99), 'monthly' ($9.99), 'protocol_100' ($29.99). **NO existe 'yearly'**, `stripe_customer_id TEXT`, `stripe_subscription_id TEXT`, `trial_starts_at TIMESTAMPTZ DEFAULT NOW()` — **CAMBIO v2.0**: renombrado per ADRs, `trial_ends_at TIMESTAMPTZ` — trial_starts_at + 5 días, `current_period_start TIMESTAMPTZ`, `current_period_end TIMESTAMPTZ`, `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`. | Tabla existe. status DEFAULT 'trial'. Plan acepta 'weekly', 'monthly', 'protocol_100'. NO acepta 'yearly'. |
| 03.1.3.5 | Crear tabla `daily_tasks` | [SQL] | Tareas diarias del protocolo. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `day_number SMALLINT NOT NULL`, `category task_category_enum NOT NULL` — 17 categorías, `archetype task_archetype_enum NOT NULL` — 5 arquetipos, `title TEXT NOT NULL`, `description TEXT`, `status task_status_enum DEFAULT 'pending'` — **CAMBIO v2.0**: ahora 4 estados (pending, in_progress, completed, failed), `scheduled_date DATE NOT NULL`, `completed_at TIMESTAMPTZ`, `completion_notes TEXT`, `actual_duration_minutes SMALLINT`, `tool_type tool_type_enum` — herramienta asociada (puede ser NULL), `tool_data JSONB` — datos específicos de la herramienta, `btc_earned INTEGER DEFAULT 0`, `vector_changes JSONB` — `{"aura":+0.5,"jawline":0,...}`, `repetition_number SMALLINT DEFAULT 1` — para diminishing returns, `idempotency_key TEXT`, `expires_at TIMESTAMPTZ` — **ADRs §4.2**: timestamp de expiración de la tarea, `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`. Constraint UNIQUE en `(user_id, scheduled_date, category)`. | Tabla existe con 19 columnas. ENUM category acepta las 17 categorías. status acepta 4 valores (pending, in_progress, completed, failed). UNIQUE constraint funciona. |
| 03.1.3.6 | Crear tabla `daily_logs` | [SQL] | Historial de Judgement Night con snapshot de 6 vectores. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `day_number SMALLINT NOT NULL`, `log_date DATE NOT NULL`, `day_status day_status_enum NOT NULL` — **CAMBIO v2.0**: 3 estados (success/failed/death), `tasks_completed SMALLINT DEFAULT 0`, `tasks_total SMALLINT DEFAULT 0`, `completion_rate NUMERIC(5,2)` — porcentaje 0-100, `vectors_snapshot JSONB NOT NULL` — **DEBE contener 6 vectores**: `{"aura_lvl":X,"jawline_lvl":X,"wealth_lvl":X,"physique_lvl":X,"social_lvl":X,"env_lvl":X}`, `overall_score_snapshot NUMERIC(5,2)`, `level_snapshot SMALLINT`, `health_before SMALLINT`, `health_after SMALLINT`, `health_change SMALLINT`, `streak_before SMALLINT`, `streak_after SMALLINT`, `btc_earned INTEGER DEFAULT 0`, `btc_lost INTEGER DEFAULT 0`, `image_url TEXT`, `notes TEXT`, `created_at TIMESTAMPTZ DEFAULT NOW()`. Constraint UNIQUE en `(user_id, day_number)`. | Tabla existe. day_status acepta 3 valores (no 4). vectors_snapshot JSONB con 6 vectores. UNIQUE en (user_id, day_number). |
| 03.1.3.7 | Crear tabla `store_items` | [SQL] | Catálogo de tienda. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `name TEXT NOT NULL`, `description TEXT`, `category item_category_enum NOT NULL`, `rarity item_rarity_enum NOT NULL DEFAULT 'common'` — **CAMBIO v2.0**: 4 rarezas (sin 'uncommon'), `slot item_slot_enum` — NULL para powerups/vehicles/properties, `price_btc INTEGER NOT NULL CHECK (price_btc > 0)`, `level_required SMALLINT DEFAULT 1 CHECK (level_required BETWEEN 1 AND 12)` — **CAMBIO v2.0**: max 12 (no 13), `vector_requirements JSONB` — `{"wealth_lvl":10,"physique_lvl":15}` umbrales mínimos, `streak_required SMALLINT DEFAULT 0`, `ai_token TEXT` — **CAMBIO v2.0**: renombrado de 'ia_token' a 'ai_token' per ADRs, `image_preview_url TEXT`, `is_premium BOOLEAN DEFAULT FALSE` — solo suscriptores activos, `is_active BOOLEAN DEFAULT TRUE`, `max_per_user SMALLINT` — NULL = ilimitado, `created_at TIMESTAMPTZ DEFAULT NOW()`. | Tabla existe. rarity acepta 4 valores (NO 'uncommon'). level_required 1-12. vector_requirements usa nombres _lvl en JSONB. |
| 03.1.3.8 | Crear tabla `inventory` | [SQL] | Items del usuario. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `item_id UUID NOT NULL REFERENCES store_items(id)`, `is_equipped BOOLEAN DEFAULT FALSE`, `equipped_slot item_slot_enum`, `locked_by_death BOOLEAN DEFAULT FALSE` — **Constantes §5.6**: items bloqueados tras muerte, `acquired_at TIMESTAMPTZ DEFAULT NOW()`, `unlock_cost_btc INTEGER` — costo para desbloquear tras muerte. Constraint UNIQUE en `(user_id, item_id, equipped_slot)`. | Tabla existe. locked_by_death DEFAULT FALSE. |
| 03.1.3.9 | Crear tabla `tool_progress` | [SQL] | Progreso de las 9 herramientas. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `tool_type tool_type_enum NOT NULL`, `total_sessions INTEGER DEFAULT 0`, `total_duration_seconds INTEGER DEFAULT 0` — **CAMBIO v2.0**: en segundos (no minutos) per ADRs §4.2, `current_streak SMALLINT DEFAULT 0`, `best_streak SMALLINT DEFAULT 0`, `last_session_at TIMESTAMPTZ`, `tool_data JSONB` — datos según herramienta (ej: libros leídos en logbook, ejercicios en metagym, palabras en journal), `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`. Constraint UNIQUE en `(user_id, tool_type)`. | Tabla existe. tool_type acepta 9 valores. UNIQUE en (user_id, tool_type). total_duration_seconds (no minutes). |
| 03.1.3.10 | Crear tabla `activity_logs` | [SQL] | Logs de actividad para auditoría. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `action TEXT NOT NULL` — 'task_completed', 'item_purchased', 'death', 'level_up', 'login', 'logout', etc., `entity_type TEXT` — 'task', 'item', 'avatar', 'subscription', etc., `entity_id UUID`, `metadata JSONB` — datos adicionales del evento, `ip_address TEXT` — **ADRs §4.2**: para auditoría de seguridad, `user_agent TEXT` — **ADRs §4.2**, `created_at TIMESTAMPTZ DEFAULT NOW()`. | Tabla existe. Acepta inserts con action, metadata JSONB, ip_address y user_agent. |
| 03.1.3.11 | Crear tabla `image_generation_queue` | [SQL] | Cola de generación de imágenes IA. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `day_number SMALLINT NOT NULL`, `base_avatar_id SMALLINT NOT NULL CHECK (base_avatar_id BETWEEN 1 AND 6)` — 6 personajes, `vectors_snapshot JSONB NOT NULL` — snapshot de 6 vectores al momento, `equipped_items_tokens TEXT[]` — **CAMBIO v2.0**: array de ai_tokens de items equipados (no JSONB de IDs), `health_points SMALLINT`, `status image_gen_status_enum DEFAULT 'pending'` — **CAMBIO v2.0**: 5 estados (incluye 'retrying'), `priority SMALLINT DEFAULT 5` — 1=más alta, 10=más baja, `provider TEXT DEFAULT 'gemini'` — **CAMBIO v2.0**: Gemini 2.5 Flash es **único proveedor**. NO [fal.ai](http://fal.ai). Per Constantes §3, `request_id TEXT`, `result_url TEXT`, `error_message TEXT`, `attempts SMALLINT DEFAULT 0`, `max_attempts SMALLINT DEFAULT 3`, `prompt_used TEXT`, `created_at TIMESTAMPTZ DEFAULT NOW()`, `processed_at TIMESTAMPTZ`. | Tabla existe. provider DEFAULT 'gemini' (NO 'fal-ai'). base_avatar_id acepta 1-6. status acepta 5 valores incluido 'retrying'. |
| 03.1.3.12 | Crear tabla `notifications` | [SQL] | Notificaciones del usuario. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `type notification_type_enum NOT NULL` — **CAMBIO v2.0**: 10 tipos actualizados, `title TEXT NOT NULL`, `message TEXT NOT NULL` — **CAMBIO v2.0**: renombrado de 'body' a 'message' per ADRs, `metadata JSONB`, `is_read BOOLEAN DEFAULT FALSE`, `read_at TIMESTAMPTZ`, `expires_at TIMESTAMPTZ`, `created_at TIMESTAMPTZ DEFAULT NOW()`. | Tabla existe. type acepta 10 valores. message (no body). |
| 03.1.3.13 | Crear tabla `idempotency_keys` | [SQL] | Prevención de double-clicks. **ADR-003**. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `key TEXT NOT NULL UNIQUE`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `action TEXT NOT NULL` — 'complete_task', 'purchase_item', etc., `result JSONB`, `status TEXT DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed'))`, `created_at TIMESTAMPTZ DEFAULT NOW()`, `expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '24 hours'`. | Tabla existe. key es UNIQUE. expires_at se calcula automáticamente. |
| 03.1.3.14 | Crear tabla `payments` | [SQL] | Registro de pagos Stripe. Campos: `id UUID DEFAULT uuid_generate_v4() PRIMARY KEY`, `user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE`, `stripe_payment_intent_id TEXT`, `stripe_invoice_id TEXT`, `stripe_event_id TEXT UNIQUE` — **PRD US-PAY-002**: idempotencia webhook por event_id, `amount_cents INTEGER NOT NULL`, `currency TEXT DEFAULT 'usd'`, `status payment_status_enum DEFAULT 'pending'`, `plan TEXT`, `metadata JSONB`, `created_at TIMESTAMPTZ DEFAULT NOW()`. | Tabla existe. stripe_event_id es UNIQUE para idempotencia de webhooks. |

---

## 03.1.4 — ÍNDICES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.1.4.1 | Índice en `profiles.email` | [SQL] | `CREATE UNIQUE INDEX idx_profiles_email ON profiles(email);` | Index existe y es UNIQUE. |
| 03.1.4.2 | Índice en `profiles.nickname` | [SQL] | `CREATE UNIQUE INDEX idx_profiles_nickname ON profiles(nickname);` — **PRD US-PROF-001**: nickname es único. | Index existe y es UNIQUE. |
| 03.1.4.3 | Índice en `profiles.phone_encrypted` | [SQL] | `CREATE UNIQUE INDEX idx_profiles_phone ON profiles(phone_encrypted) WHERE phone_encrypted IS NOT NULL;` — **PRD US-AUTH-003**: 1 teléfono = 1 cuenta. Partial index. | Index existe, UNIQUE parcial. |
| 03.1.4.4 | Índice en `avatar_states.user_id` | [SQL] | `CREATE UNIQUE INDEX idx_avatar_states_user_id ON avatar_states(user_id);` | Index existe. |
| 03.1.4.5 | Índice en `wallets.user_id` | [SQL] | `CREATE UNIQUE INDEX idx_wallets_user_id ON wallets(user_id);` | Index existe. |
| 03.1.4.6 | Índice en `subscriptions.user_id` | [SQL] | `CREATE UNIQUE INDEX idx_subscriptions_user_id ON subscriptions(user_id);` | Index existe. |
| 03.1.4.7 | Índice en `subscriptions.stripe_customer_id` | [SQL] | `CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id) WHERE stripe_customer_id IS NOT NULL;` — Partial index para búsquedas desde webhooks Stripe. | Index existe, es parcial. |
| 03.1.4.8 | Índice compuesto en `daily_tasks` por usuario+fecha | [SQL] | `CREATE INDEX idx_daily_tasks_user_date ON daily_tasks(user_id, scheduled_date);` — Query principal del dashboard: obtener tareas del día. | Index existe. |
| 03.1.4.9 | Índice en `daily_tasks` por status pending | [SQL] | `CREATE INDEX idx_daily_tasks_pending ON daily_tasks(user_id, status) WHERE status = 'pending';` — Partial index para tareas pendientes (query más frecuente). | Index existe, es parcial. |
| 03.1.4.10 | Índice en `daily_tasks.idempotency_key` | [SQL] | `CREATE UNIQUE INDEX idx_daily_tasks_idempotency ON daily_tasks(idempotency_key) WHERE idempotency_key IS NOT NULL;` — Prevenir double-completion. | Index existe, UNIQUE parcial. |
| 03.1.4.11 | Índice compuesto en `daily_logs` por usuario+día | [SQL] | `CREATE UNIQUE INDEX idx_daily_logs_user_day ON daily_logs(user_id, day_number);` | Index existe. |
| 03.1.4.12 | Índice en `daily_logs` por fecha | [SQL] | `CREATE INDEX idx_daily_logs_date ON daily_logs(user_id, log_date DESC);` — Para historial cronológico. | Index existe. |
| 03.1.4.13 | Índice compuesto en `inventory` | [SQL] | `CREATE INDEX idx_inventory_user ON inventory(user_id, is_equipped);` — Para obtener items equipados rápido. | Index existe. |
| 03.1.4.14 | Índice compuesto en `tool_progress` | [SQL] | `CREATE UNIQUE INDEX idx_tool_progress_user_tool ON tool_progress(user_id, tool_type);` | Index existe. |
| 03.1.4.15 | Índice en `activity_logs` por usuario+fecha | [SQL] | `CREATE INDEX idx_activity_logs_user_date ON activity_logs(user_id, created_at DESC);` | Index existe. |
| 03.1.4.16 | Índice en `image_generation_queue` por status | [SQL] | `CREATE INDEX idx_image_queue_status ON image_generation_queue(status, priority) WHERE status IN ('pending', 'retrying');` — Worker poll de jobs pendientes y retrying. | Index existe, parcial. |
| 03.1.4.17 | Índice en `notifications` por usuario no leídas | [SQL] | `CREATE INDEX idx_notifications_unread ON notifications(user_id, created_at DESC) WHERE is_read = FALSE;` | Index existe, parcial. |
| 03.1.4.18 | Índice en `idempotency_keys.key` | [SQL] | `CREATE UNIQUE INDEX idx_idempotency_key ON idempotency_keys(key);` | Index existe. |
| 03.1.4.19 | Índice en `idempotency_keys` para cleanup | [SQL] | `CREATE INDEX idx_idempotency_expires ON idempotency_keys(expires_at) WHERE status = 'processing';` — Para job de limpieza de keys expiradas. | Index existe, parcial. |
| 03.1.4.20 | Índice en `payments.stripe_payment_intent_id` | [SQL] | `CREATE INDEX idx_payments_stripe ON payments(stripe_payment_intent_id) WHERE stripe_payment_intent_id IS NOT NULL;` | Index existe. |
| 03.1.4.21 | Índice en `payments.stripe_event_id` | [SQL] | `CREATE UNIQUE INDEX idx_payments_event ON payments(stripe_event_id) WHERE stripe_event_id IS NOT NULL;` — Idempotencia webhook. | Index existe, UNIQUE parcial. |

---

## 03.1.5 — FUNCIONES DE UPDATED_AT AUTOMÁTICO

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.1.5.1 | Crear función `fn_set_updated_at` | [SQL] | `CREATE OR REPLACE FUNCTION fn_set_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = NOW(); RETURN NEW; END; $$ LANGUAGE plpgsql;` — Función genérica reutilizable por todos los triggers de updated_at. | Función existe en `pg_proc`. |
| 03.1.5.2 | Trigger updated_at en `profiles` | [SQL] | `CREATE TRIGGER trg_profiles_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();` | UPDATE en profiles actualiza updated_at automáticamente. |
| 03.1.5.3 | Trigger updated_at en `avatar_states` | [SQL] | `CREATE TRIGGER trg_avatar_states_updated_at BEFORE UPDATE ON avatar_states FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();` | UPDATE en avatar_states actualiza updated_at. |
| 03.1.5.4 | Trigger updated_at en `wallets` | [SQL] | `CREATE TRIGGER trg_wallets_updated_at BEFORE UPDATE ON wallets FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();` | UPDATE en wallets actualiza updated_at. |
| 03.1.5.5 | Trigger updated_at en `subscriptions` | [SQL] | `CREATE TRIGGER trg_subscriptions_updated_at BEFORE UPDATE ON subscriptions FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();` | UPDATE en subscriptions actualiza updated_at. |
| 03.1.5.6 | Trigger updated_at en `daily_tasks` | [SQL] | `CREATE TRIGGER trg_daily_tasks_updated_at BEFORE UPDATE ON daily_tasks FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();` | UPDATE en daily_tasks actualiza updated_at. |
| 03.1.5.7 | Trigger updated_at en `tool_progress` | [SQL] | `CREATE TRIGGER trg_tool_progress_updated_at BEFORE UPDATE ON tool_progress FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();` | UPDATE en tool_progress actualiza updated_at. |

---

## 03.1.6 — TRIGGERS DE VALIDACIÓN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.1.6.1 | Crear función `fn_validate_vector_range` | [SQL] | Trigger function que valida los 6 vectores en `avatar_states` antes de INSERT/UPDATE. Verifica: `aura_lvl BETWEEN 0.00 AND 50.00`, `jawline_lvl BETWEEN 0.00 AND 50.00`, `wealth_lvl BETWEEN 0.00 AND 50.00`, `physique_lvl BETWEEN 0.00 AND 50.00`, `social_lvl BETWEEN 0.00 AND 50.00`, `env_lvl BETWEEN 1 AND 10`. Si cualquier vector está fuera de rango, RAISE EXCEPTION con nombre del vector y valor actual. | Función rechaza valores fuera de rango para cada uno de los 6 vectores. Test: INSERT con social_lvl=51 falla. INSERT con jawline_lvl=-1 falla. INSERT con env_lvl=0 falla. |
| 03.1.6.2 | Trigger de validación de vectores | [SQL] | `CREATE TRIGGER trg_validate_vectors BEFORE INSERT OR UPDATE ON avatar_states FOR EACH ROW EXECUTE FUNCTION fn_validate_vector_range();` | Trigger activo en avatar_states. |
| 03.1.6.3 | Crear función `fn_validate_daily_cap` | [SQL] | Trigger function para validar que `today_earned` no exceda `daily_cap` en wallets. Si `NEW.today_earned > NEW.daily_cap` → clampear a daily_cap. **Constantes §5.6**: cap de **2,000 BTC/día**. No rechaza, sino que clampea al cap. | Función existe. UPDATE con today_earned=2500 resulta en today_earned=2000 (si daily_cap=2000). |
| 03.1.6.4 | Trigger de validación daily cap | [SQL] | `CREATE TRIGGER trg_validate_daily_cap BEFORE UPDATE ON wallets FOR EACH ROW EXECUTE FUNCTION fn_validate_daily_cap();` | Trigger activo en wallets. |
| 03.1.6.5 | Crear función `fn_validate_hibernation` | [SQL] | Previene operaciones en avatares hibernados. Si `OLD.is_hibernated = TRUE AND NEW.is_hibernated = TRUE`, verifica que ningún vector principal (aura, jawline, wealth, physique, social) haya cambiado. Si cambió alguno, RAISE EXCEPTION 'Avatar is hibernated. No vector changes allowed.' **Constantes §5.6**: tras 3ª+ muerte, hibernación (sin más progreso). | Función rechaza cambios de vectores en avatares hibernados. |
| 03.1.6.6 | Trigger de validación hibernación | [SQL] | `CREATE TRIGGER trg_validate_hibernation BEFORE UPDATE ON avatar_states FOR EACH ROW EXECUTE FUNCTION fn_validate_hibernation();` | Trigger activo. Avatar hibernado no acepta cambios de vectores. |
| 03.1.6.7 | Crear función `fn_validate_timezone_cooldown` | [SQL] | Trigger function para validar cooldown de 30 días entre cambios de timezone en profiles. Si `OLD.timezone != NEW.timezone`, verificar `OLD.timezone_changed_at IS NULL OR OLD.timezone_changed_at < NOW() - INTERVAL '30 days'`. Si no cumple cooldown, RAISE EXCEPTION. Si cumple, SET `NEW.timezone_changed_at = NOW()`. **Constantes §5.12**: cooldown 30 días. | Función rechaza cambio de timezone si no han pasado 30 días. Primer cambio siempre permitido (timezone_changed_at NULL). |
| 03.1.6.8 | Trigger de validación timezone cooldown | [SQL] | `CREATE TRIGGER trg_validate_timezone_cooldown BEFORE UPDATE ON profiles FOR EACH ROW WHEN (OLD.timezone IS DISTINCT FROM NEW.timezone) EXECUTE FUNCTION fn_validate_timezone_cooldown();` | Trigger activo solo cuando timezone cambia. |

---

## 03.1.7 — TRIGGER DE AUTO-CREACIÓN DE REGISTROS

| ID | Título | Tipo | Detalle | Validación |  |  |
| --- | --- | --- | --- | --- | --- | --- |
| 03.1.7.1 | Crear función `fn_handle_new_user` | [SQL] | Trigger function que se ejecuta cuando Supabase Auth crea un nuevo usuario. SECURITY DEFINER SET search_path = public. Crea automáticamente: 1) `profiles` con email, nickname generado (`'METAMEN-' \ | \ | LPAD(nextval('nickname_seq')::TEXT, 4, '0')`), base_avatar_id=1 (temporal, se actualiza en onboarding), locale='es-MX', timezone='America/Mexico_City'. 2)` avatar_states `con vectores en 0, env=1, health=5, max_health=10, level=1. 3)` wallets `con btc_balance=0 y daily_cap=**2000**. 4)` subscriptions `con status='trial', trial_starts_at=NOW(), trial_ends_at=NOW()+5 days. 5)` tool_progress` — **9 filas**, una por herramienta: meditation, focus_timer, lookmaxing, journal, logbook, kegel, posture, metagym, voice. | Crear usuario en auth.users genera automáticamente: 1 profile (nickname METAMEN-XXXX), 1 avatar_state (health=5, vectores=0, level=1), 1 wallet (cap=**2000**), 1 subscription (trial, +5 days), 9 tool_progress rows. |
| 03.1.7.2 | Trigger on auth.users INSERT | [SQL] | `CREATE TRIGGER trg_on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION fn_handle_new_user();` | Trigger activo en auth.users. |  |  |

---
# ══════════════════════════════════════════════════════════════

# SUBCAJA 03.2 — FUNCIONES PostgreSQL

# Auxiliares · Task Config · Transacciones · Judgement · Muerte · Decay · BTC · ENV · Tienda · Onboarding

# 68 TAREAS (vs 52 original)

# ══════════════════════════════════════════════════════════════

---

## 03.2.1 — FUNCIONES AUXILIARES (Cálculos Puros)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.1.1 | Crear función `fn_clamp` | [SQL] | Función utilitaria pura. `CREATE OR REPLACE FUNCTION fn_clamp(val NUMERIC, min_val NUMERIC, max_val NUMERIC) RETURNS NUMERIC AS $$ SELECT LEAST(max_val, GREATEST(min_val, val)); $$ LANGUAGE sql IMMUTABLE PARALLEL SAFE;` — Se usa internamente en múltiples funciones para asegurar que vectores, HP, BTC nunca excedan sus límites. | `SELECT fn_clamp(105, 0, 100)` → 100. `SELECT fn_clamp(-5, 0, 100)` → 0. `SELECT fn_clamp(50, 0, 100)` → 50. Función marcada IMMUTABLE. |
| 03.2.1.2 | Crear función `fn_calculate_overall_score` | [SQL] | Calcula el Overall Score ponderado de los 6 vectores. **Constantes Maestras v2.0.0**. Parámetros: `p_aura NUMERIC, p_jawline NUMERIC, p_wealth NUMERIC, p_physique NUMERIC, p_social NUMERIC, p_env NUMERIC`. Fórmula exacta: `overall = AURA × 0.20 + JAWLINE × 0.15 + WEALTH × 0.20 + PHYSIQUE × 0.20 + SOCIAL × 0.15 + (ENV × 5) × 0.10`. **IMPORTANTE:** ENV se multiplica ×5 antes de aplicar su peso porque su escala natural es 0-20 mientras los demás vectores escalan 0-100. Resultado clampeado entre 0.00 y 100.00 vía `fn_clamp`. Retorna `NUMERIC(5,2)` redondeado a 2 decimales. Atributos: `IMMUTABLE`, `PARALLEL SAFE`, `LANGUAGE sql`. | `SELECT fn_calculate_overall_score(100,100,100,100,100,20)` = 100.00. `SELECT fn_calculate_overall_score(0,0,0,0,0,0)` = 0.00. `SELECT fn_calculate_overall_score(50,50,50,50,50,10)` = 50.00. Verificar que ENV=20 con resto en 0 da `(20×5)×0.10 = 10.00`. |
| 03.2.1.3 | Crear función `fn_determine_level` | [SQL] | Dado un overall score, retorna el nivel (`LevelName` enum) correspondiente. **12 niveles (NO 13) — Constantes Maestras v2.0.0**. Usar `CASE WHEN` descendente: ≥98.00→`SEMI-DIOS`, ≥94.00→`ÉLITE`, ≥87.00→`MAGNATE`, ≥79.00→`MILLONARIO`, ≥68.00→`PUDIENTE`, ≥57.00→`INFLUYENTE`, ≥45.00→`HOMBRE COMÚN`, ≥35.00→`PEÓN`, ≥23.00→`ALUCÍN`, ≥13.00→`MANTENIDO`, ≥5.00→`REFUGIADO`, ELSE→`INDIGENTE`. Retorna `TEXT` que castea a enum `LevelName`. Atributos: `IMMUTABLE`, `PARALLEL SAFE`, `LANGUAGE sql`. | score=0→INDIGENTE. score=5→REFUGIADO. score=23→ALUCÍN. score=45→HOMBRE COMÚN. score=98→SEMI-DIOS. score=100→SEMI-DIOS. **Verificar que NO existe nivel 13 ni LEYENDA ni DIOS.** |
| 03.2.1.4 | Crear función `fn_get_level_index` | [SQL] | Retorna el índice numérico (0-11) de un nivel dado su nombre. INDIGENTE=0, REFUGIADO=1, MANTENIDO=2, ALUCÍN=3, PEÓN=4, HOMBRE COMÚN=5, INFLUYENTE=6, PUDIENTE=7, MILLONARIO=8, MAGNATE=9, ÉLITE=10, SEMI-DIOS=11. Se usa para cálculos de multiplicador BTC. Atributos: `IMMUTABLE`, `LANGUAGE sql`. | `fn_get_level_index('INDIGENTE')` → 0. `fn_get_level_index('SEMI-DIOS')` → 11. **12 valores, NO 13.** |
| 03.2.1.5 | Crear función `fn_calculate_btc_multiplier` | [SQL] | Calcula el multiplicador BTC **ADITIVO** (NO multiplicativo). **Constantes Maestras v2.0.0**: `multiplier = 1.0 + (level_index × 0.05) + streak_bonus + subscription_bonus`. Parámetros: `p_user_id UUID`. Lógica: 1) Consultar `profiles` → calcular overall → `fn_determine_level` → `fn_get_level_index`. 2) Consultar `wallets` para `current_streak`. 3) Consultar `subscriptions` para plan activo. **Streak bonus (aditivo):** 0d→0.0, 1-7d→0.1, 8-14d→0.5, 15+d→1.5. **Subscription bonus:** sin sub→0.0, weekly→0.05, monthly→0.10, protocol_100→0.20. **Planes válidos: weekly, monthly, protocol_100 (NO yearly, NO annual).** Resultado mínimo siempre 1.0. Retorna `NUMERIC(4,2)`. Atributos: `STABLE`, `SECURITY DEFINER`, `LANGUAGE plpgsql`. | Level INDIGENTE(0), streak 0, sin sub → 1.0. Level PEÓN(4), streak 10d, monthly → 1.0+(4×0.05)+0.5+0.10 = 1.80. Level SEMI-DIOS(11), streak 15+, protocol_100 → 1.0+(11×0.05)+1.5+0.20 = 3.25. **Verificar que es SUMA, no multiplicación de factores.** |
| 03.2.1.6 | Crear función `fn_calculate_hp_max` | [SQL] | Calcula el HP máximo expandido de un usuario. **Constantes Maestras v2.0.0**: HP base máximo=**10**, HP expandido máximo absoluto=**14** (NO 13). Bonus por nivel: +1 HP por cada 3 niveles a partir de level_index 3 (ALUCÍN): index 0-2→+0, 3-5→+1, 6-8→+2, 9-11→+3. Bonus suscripción protocol_100 activa: +1 HP. Total = `fn_clamp(10 + level_bonus + sub_bonus, 5, 14)`. HP inicial para nuevos usuarios: **5**. Atributos: `STABLE`, `SECURITY DEFINER`, `LANGUAGE plpgsql`. | INDIGENTE sin sub → 10. ALUCÍN sin sub → 11. PUDIENTE sin sub → 12. MAGNATE sin sub → 13. MAGNATE + protocol_100 → 14. SEMI-DIOS + protocol_100 → fn_clamp(10+3+1, 5, 14) = 14. |
| 03.2.1.7 | Crear función `fn_calculate_daily_cap` | [SQL] | Retorna el cap diario de BTC. **Constantes Maestras v2.0.0**: base = **2,000 BTC** (NO 3,500). Modificadores por suscripción (tomar el mejor, no acumulativo): protocol_100 activa → cap × 1.5 = 3,000. monthly activa → cap × 1.2 = 2,400. weekly activa → cap × 1.1 = 2,200. Sin suscripción → 2,000. Retorna `INTEGER`. Atributos: `STABLE`, `SECURITY DEFINER`, `LANGUAGE plpgsql`. | Sin sub → 2000. weekly → 2200. monthly → 2400. protocol_100 → 3000. **Verificar que NO retorna 3500.** |
| 03.2.1.8 | Crear función `fn_get_vector_weights` | [SQL] | Retorna los pesos oficiales de los 6 vectores como JSONB. Retorno fijo: `{"AURA": 0.20, "JAWLINE": 0.15, "WEALTH": 0.20, "PHYSIQUE": 0.20, "SOCIAL": 0.15, "ENV": 0.10, "ENV_SCALE_FACTOR": 5}`. Pesos suman 1.0. Atributos: `IMMUTABLE`, `PARALLEL SAFE`, `LANGUAGE sql`. | JSONB válido. Suma de 6 pesos = 1.00. ENV_SCALE_FACTOR = 5. |
| 03.2.1.9 | Crear función `fn_get_death_btc_penalty` | [SQL] | Retorna el porcentaje de pérdida de BTC por muerte escalante. **Constantes Maestras v2.0.0**: 1ª muerte→30%, 2ª muerte→40%, 3ª+ muerte→50%. Parámetro `p_death_count SMALLINT` es el conteo ANTES de la muerte actual. Retorna NUMERIC. Atributos: `IMMUTABLE`, `LANGUAGE plpgsql`. | death_count=0→0.30, =1→0.40, =2→0.50, =5→0.50. |
| 03.2.1.10 | Crear función `fn_get_streak_bonus` | [SQL] | Retorna el bonus de racha **ADITIVO** (NO multiplicador). **Constantes Maestras v2.0.0**: 0 días→0.0, 1-7 días→0.1, 8-14 días→0.5, 15+ días→1.5. **NOTA:** Estos valores se SUMAN al multiplicador base, no se multiplican. Atributos: `IMMUTABLE`, `LANGUAGE sql`. | streak=0→0.0, =1→0.1, =7→0.1, =8→0.5, =14→0.5, =15→1.5, =100→1.5. **Verificar que NO retorna 1.1, 1.5, 2.5 (esos eran los multiplicativos de la versión anterior).** |
| 03.2.1.11 | Crear función `fn_get_subscription_bonus` | [SQL] | Retorna el bonus de suscripción **ADITIVO**. Sin sub→0.0, weekly→0.05, monthly→0.10, protocol_100→0.20. **Planes válidos: weekly ($2.99), monthly ($9.99), protocol_100 ($29.99). NO existe yearly ni annual.** Atributos: `IMMUTABLE`, `LANGUAGE sql`. | 'weekly'→0.05, 'monthly'→0.10, 'protocol_100'→0.20, NULL→0.0. **Verificar que NO acepta 'yearly'.** |
| 03.2.1.12 | Crear función `fn_get_diminishing_factor` | [SQL] | Calcula factor de diminishing returns para repetición de tareas. Fórmula: `max(0.25, 0.90^(rep-1))`. Floor de 25%. Parámetro: `p_repetition SMALLINT`. Atributos: `IMMUTABLE`, `LANGUAGE plpgsql`. | rep=1→1.0, rep=2→0.90, rep=3→0.81, rep=5→0.6561, rep=20→0.25 (floor). |
| 03.2.1.13 | Crear función `fn_get_health_penalty` | [SQL] | Retorna el multiplicador de BTC según salud actual. HP<3 → 0.50 (crítico). HP<8 → 0.90 (herido). HP≥8 → 1.0 (saludable). Atributos: `IMMUTABLE`, `LANGUAGE plpgsql`. | health=10→1.0, =8→1.0, =5→0.90, =2→0.50, =1→0.50. |

---

## 03.2.2 — FUNCIÓN: TASK CONFIG (Constantes del Motor)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.2.1 | Crear función `fn_get_task_config` | [SQL] | Devuelve la configuración de una categoría de tarea: vector target, UP value, DOWN value, archetype, base BTC reward, reps_per_week. **17 categorías — Constantes Maestras v2.0.0**. Parámetros OUT: `o_vector TEXT, o_up NUMERIC, o_down NUMERIC, o_archetype TaskArchetype, o_base_btc INTEGER, o_reps_per_week SMALLINT`. CASE por las 17 categorías: **AURA(4):** meditation(0.50/-0.50, WELLNESS, 50btc, 7/wk), thanks(0.50/-0.50, WELLNESS, 40btc, 7/wk), posture(1.16/-1.16, WELLNESS, 60btc, 3/wk), wake_early(0.50/-0.50, WELLNESS, 50btc, 7/wk). **JAWLINE(3):** facial(1.16/-1.16, LIFESTYLE, 80btc, 3/wk), voice(1.16/-1.16, LIFESTYLE, 70btc, 3/wk), cold_shower(1.78/-1.78, LIFESTYLE, 100btc, 2/wk). **WEALTH(3):** skill_learning(0.70/-0.70, INTELLECTUAL, 80btc, 5/wk), focus_work(0.70/-0.70, INTELLECTUAL, 80btc, 5/wk), reading(0.58/-0.58, INTELLECTUAL, 60btc, 6/wk). **PHYSIQUE(3):** strength(0.70/-0.70, WELLNESS, 100btc, 5/wk), cardio(1.16/-1.16, WELLNESS, 90btc, 3/wk), hydration(0.50/-0.50, WELLNESS, 40btc, 7/wk). **SOCIAL(4):** talk_friend(1.78/-1.78, SOCIAL, 70btc, 2/wk), family(1.78/-1.78, SOCIAL, 70btc, 2/wk), kegel(0.70/-0.70, SOCIAL, 60btc, 5/wk), journal(0.58/-0.58, INTELLECTUAL, 50btc, 6/wk). Atributos: `IMMUTABLE`, `LANGUAGE plpgsql`. | Test cada una de las 17 categorías. `fn_get_task_config('meditation')` → aura_lvl, 0.50, -0.50, WELLNESS, 50, 7. `fn_get_task_config('cold_shower')` → jawline_lvl, 1.78, -1.78, LIFESTYLE, 100, 2. Verificar 17 categorías contra Constantes Maestras. |
| 03.2.2.2 | Crear función `fn_get_task_categories_by_archetype` | [SQL] | Retorna las categorías agrupadas por los **5 arquetipos — Constantes Maestras v2.0.0**: WELLNESS, INTELLECTUAL, SOCIAL, FINANCIAL, LIFESTYLE. Retorna JSONB con mapping: WELLNESS→[meditation, thanks, posture, wake_early, strength, cardio, hydration, cold_exposure, nutrition], INTELLECTUAL→[reading, skill_learning, journaling, content_creation], SOCIAL→[social_interaction, networking, mentoring], FINANCIAL→[financial_task, investment_research, side_hustle], LIFESTYLE→[grooming, style_upgrade, charity]. Atributos: `IMMUTABLE`, `LANGUAGE sql`. | JSONB válido. 5 arquetipos. Suma total de categorías = 17. |
| 03.2.2.3 | Crear función `fn_get_difficulty_config` | [SQL] | Retorna configuración de dificultad y multiplicadores. 4 niveles: easy(btc×1.0, vector×1.0, "5-15min"), medium(btc×1.5, vector×1.3, "15-45min"), hard(btc×2.5, vector×1.8, "45-90min"), epic(btc×4.0, vector×2.5, "90+min", disponible desde INFLUYENTE index≥6). Retorna JSONB. Atributos: `IMMUTABLE`, `LANGUAGE sql`. | 4 niveles de dificultad. epic requiere level_index ≥ 6. |
| 03.2.2.4 | Crear función `fn_get_tools_config` | [SQL] | Retorna configuración de las **9 herramientas — Constantes Maestras v2.0.0**. Cada herramienta incluye: tool_id, display_name, description, price_btc, rarity (4 niveles: common, rare, epic, legendary — **'uncommon' ELIMINADO**), vectors_boosted, boost_percentage, duration_hours, level_required, max_stack, category_affinity. Las 9 herramientas: GOLDEN_RAZOR, POWER_SHAKE, CHARM_COLOGNE, BRAIN_SERUM, STREET_CRED_CARD, COLD_SHOWER_TIMER, MUSCLE_BANDS, VISION_BOARD, GRIND_PLAYLIST. Retorna JSONB. Atributos: `IMMUTABLE`, `LANGUAGE sql`. | 9 herramientas. Rarities = 4 (NO 5, sin 'uncommon'). Cada herramienta tiene todos los campos requeridos. |
| 03.2.2.5 | Crear función `fn_get_characters_config` | [SQL] | Retorna configuración de los **6 personajes base — Constantes Maestras v2.0.0**: base_avatar_id 1→EL_RASTAS, 2→EL_GUARRO, 3→EL_PECAS, 4→EL_GREÑAS, 5→EL_GUERO, 6→EL_LIC. Cada personaje incluye: id, name, display_name, description, visual_prompt_anchor. Retorna JSONB. Atributos: `IMMUTABLE`, `LANGUAGE sql`. | 6 personajes. IDs 1-6. Nombres correctos. |

---

## 03.2.3 — FUNCIÓN: COMPLETAR TAREA (Transacción Principal)

| ID | Título | Tipo | Detalle | Validación |  |
| --- | --- | --- | --- | --- | --- |
| 03.2.3.1 | Crear función `fn_complete_task_transaction` | [SQL] | **Función transaccional principal**. SECURITY DEFINER SET search_path = public. Parámetros: `p_user_id UUID, p_task_id UUID, p_idempotency_key TEXT, p_completion_notes TEXT DEFAULT NULL, p_actual_duration_minutes SMALLINT DEFAULT NULL, p_tool_data JSONB DEFAULT NULL`. Retorna `JSONB` con Result Monad `{ "ok": true, "value": {...} }` | `{ "ok": false, "error": "..." }`. **Lógica paso a paso:** 1) **Idempotencia (ADR-003):** SELECT idempotency_keys WHERE key=p_idempotency_key. Si existe y status='completed' → retornar result guardado. Si existe y status='processing' → `{"ok":false,"error":"ALREADY_PROCESSING"}`. Si no existe → INSERT con status='processing'. 2) **Lock tarea:** `SELECT daily_tasks FOR UPDATE` WHERE id=p_task_id AND user_id=p_user_id AND status='pending'. Si no existe → `{"ok":false,"error":"TASK_NOT_AVAILABLE"}`. 3) **Lock avatar:** `SELECT profiles FOR UPDATE` WHERE id=p_user_id. Verificar `oath_taken = true`. Verificar NO en hibernación vía `avatar_deaths`. 4) **Lock wallet:** `SELECT wallets FOR UPDATE` WHERE user_id=p_user_id. 5) **Config tarea:** `SELECT * FROM fn_get_task_config(v_task.category)`. 6) **Repeticiones hoy:** COUNT completadas misma categoría misma fecha. 7) **Diminishing:** `fn_get_diminishing_factor(v_rep + 1)`. 8) **Vector change:** `v_up = o_up × diminishing_factor`. Aplicar al vector correspondiente con `fn_clamp(valor + v_up, 0, 100)` (ENV max 20). 9) **Recalcular overall:** `fn_calculate_overall_score(...)`. 10) **Recalcular nivel:** `fn_determine_level(overall)`. 11) **BTC reward (ADITIVO):** `v_btc = FLOOR(o_base_btc × fn_calculate_btc_multiplier(p_user_id) × fn_get_health_penalty(hp) × diminishing)`. **NOTA:** `fn_calculate_btc_multiplier` ya incluye level+streak+sub como SUMA. 12) **Daily cap:** Si `btc_earned_today + v_btc > fn_calculate_daily_cap(p_user_id)` → recortar: `v_btc = GREATEST(0, cap - earned)`. 13) **UPDATE daily_tasks:** status='completed', completed_at=NOW(), btc_earned, vector_changes JSONB, notas, duración, tool_data, idempotency_key. 14) **UPDATE profiles:** vectores actualizados, overall_score, recalcular nivel. Si nivel cambió → INSERT level_history. 15) **UPDATE wallets:** btc_balance += v_btc, btc_earned_today += v_btc, total_btc_earned += v_btc. 16) **INSERT btc_transactions:** type='task_reward', amount=v_btc, metadata con detalles de cálculo. 17) **UPDATE daily_logs:** tasks_completed++, btc_earned+=v_btc, completion_percentage recalculada. 18) **INSERT activity_logs.** 19) **UPDATE idempotency_keys** SET status='completed', result=v_result. 20) **RETURN** `{"ok":true,"value":{"task_id":"...","btc_earned":N,"multiplier_applied":N,"cap_limited":bool,"vectors_updated":{...},"new_overall":N,"level_changed":bool,"current_level":"...","new_balance":N}}`. | **Tests exhaustivos:** 1) Completar meditation: vector aura sube, btc>0, status='completed'. 2) Repetir misma categoría: diminishing aplica. 3) Idempotencia: misma key retorna mismo resultado. 4) Daily cap 2000: si btc_earned_today≈2000, reward se recorta. 5) Hibernación: `{"ok":false}`. 6) Tarea ya completada: `{"ok":false}`. 7) Level up: si overall cruza umbral. 8) Vector clamp: no excede 100 ni 20 para ENV. 9) **Multiplicador es ADITIVO no multiplicativo.** 10) Result monad usa `ok/value` NO `success/data`. |
| 03.2.3.2 | Crear función `fn_start_task` | [SQL] | Marca tarea como `in_progress`. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_task_id UUID`. Validaciones: tarea existe, pertenece al usuario, status='pending', fecha=CURRENT_DATE, no más de 1 tarea in_progress simultánea, usuario no en hibernación. Acción: UPDATE daily_tasks SET status='in_progress', started_at=NOW(). Retorna `{"ok":true,"value":{"task_id":"...","started_at":"..."}}`. | Tarea cambia a in_progress. Segunda tarea in_progress simultánea → error. |  |
| 03.2.3.3 | Crear función `fn_fail_task` | [SQL] | Marca tarea como `failed`. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_task_id UUID, p_reason TEXT DEFAULT 'user_skipped'`. Validaciones: tarea existe, pertenece al usuario, status IN ('pending','in_progress'), fecha=CURRENT_DATE. Acción: UPDATE status='failed', failed_at=NOW(), reason en metadata. Actualizar daily_logs.completion_percentage. Retorna `{"ok":true,"value":{"task_id":"...","new_completion_pct":N}}`. | Status cambia a failed. completion_percentage recalculada. |  |
| 03.2.3.4 | Verificar SECURITY DEFINER en `fn_complete_task_transaction` | [MANUAL] | La función DEBE ser `SECURITY DEFINER SET search_path = public`. Verificar que NO es SECURITY INVOKER. `SELECT prosecdef FROM pg_proc WHERE proname = 'fn_complete_task_transaction'` debe retornar TRUE. | prosecdef = TRUE. |  |

---

## 03.2.4 — FUNCIÓN: JUDGEMENT NIGHT (Pipeline de Cierre de Día)

| ID | Título | Tipo | Detalle | Validación |  |  |
| --- | --- | --- | --- | --- | --- | --- |
| 03.2.4.1 | Crear función `fn_process_judgement_night` | [SQL] | **Pipeline completo de Judgement Night**. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_date DATE DEFAULT CURRENT_DATE`. Retorna JSONB con Result Monad. **Lógica:** 1) **Advisory lock:** `pg_advisory_xact_lock(hashtext(p_user_id::text))`. 2) **Verificar hibernación:** Si usuario en hibernación → `{"ok":true,"value":{"skipped":true,"reason":"hibernated"}}`. 3) **Verificar juicio previo:** Si daily_logs ya tiene judgement_executed=true para esta fecha → `{"ok":false,"error":"ALREADY_JUDGED"}`. 4) **Contar tareas:** `completed = COUNT WHERE status='completed'`, `total = COUNT all tasks del día`. 5) **Completion rate:** `rate = (completed / NULLIF(total, 0)) × 100`. 6) **Juicio BINARIO — Constantes Maestras v2.0.0:** `rate >= 80%` → **SUCCESS**: +1 HP, streak+1, day_status='success'. `rate < 80%` → **FAILED**: -1 HP, streak=0, day_status='failed'. **NO existe 'partial'. NO existen escalones intermedios (60%, 40%). Es BINARIO.** 7) **Si SUCCESS:** HP = `fn_clamp(current_hp + 1, 1, fn_calculate_hp_max(p_user_id))`. streak += 1. Actualizar longest_streak si aplica. 8) **Si FAILED:** HP = current_hp - 1. streak = 0. 9) **Verificar muerte:** Si HP <= 0 → invocar `fn_execute_avatar_death(p_user_id)`. Cambiar day_status a 'death'. 10) **Recalcular ENV:** `fn_recalculate_env(p_user_id)` (streak y sub pueden haber cambiado). 11) **Recalcular overall_score y nivel.** 12) **UPDATE profiles** con vectores, overall, nivel. 13) **UPDATE wallets** con streak, HP. 14) **UPDATE daily_logs:** status, judgement_executed=true, judgement_at=NOW(), snapshot de 6 vectores. 15) **INSERT notification** tipo 'judgement_success' o 'judgement_failed'. 16) **Encolar imagen** en image_generation_queue con vectores snapshot, priority: death=1, failed=3, success=7. 17) **RETURN** `{"ok":true,"value":{"date":"...","completion_pct":N,"result":"success | failed | death","hp_change":N,"new_hp":N,"streak":N,"death_triggered":bool,"new_level":"..."}}`. | **Tests:** 1) 100% → success, +1HP, streak+1. 2) 80% exacto → success. 3) 79.9% → failed, -1HP, streak=0. 4) 0% → failed, -1HP. 5) HP llega a 0 → muerte ejecutada. 6) Hibernado → skipped. 7) Advisory lock previene doble ejecución. 8) **Verificar que NO existe resultado 'partial'. Es BINARIO.** 9) Result monad usa `ok/value`. 10) day_status enum solo acepta 'success', 'failed', 'death'. |
| 03.2.4.2 | Crear función `fn_process_judgement_batch` | [SQL] | Ejecuta el juicio nocturno en lote para TODOS los usuarios con daily_logs pendientes. SECURITY DEFINER. Parámetro: `p_date DATE DEFAULT CURRENT_DATE`. Lógica: 1) Seleccionar daily_logs WHERE date=p_date AND judgement_executed=false. 2) **Filtrar por timezone:** Solo juzgar usuarios cuya hora local sea ≥ 23:59 (consultar profiles.timezone). 3) Para cada usuario: invocar `fn_process_judgement_night(user_id, p_date)`. 4) Acumular resultados y errores. Retorna `{"ok":true,"value":{"total_users":N,"successes":N,"failures":N,"deaths":N,"errors":N}}`. **Diseño para Inngest cron.** | Batch procesa solo usuarios cuyo timezone indica fin de día. Errores individuales no detienen el batch. |  |  |
| 03.2.4.3 | Verificar SECURITY DEFINER + advisory lock | [MANUAL] | `fn_process_judgement_night` debe ser SECURITY DEFINER. Advisory lock usa `pg_advisory_xact_lock` (se libera automáticamente al final de la transacción). Simular ejecución concurrente: segunda llamada espera a que primera termine. | prosecdef=TRUE. Lock funciona. |  |  |

---

## 03.2.5 — FUNCIÓN: MUERTE DEL AVATAR

| ID | Título | Tipo | Detalle | Validación |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 03.2.5.1 | Crear función `fn_execute_avatar_death` | [SQL] | **Proceso de muerte**. SECURITY DEFINER. Parámetro: `p_user_id UUID`. Retorna JSONB Result Monad. **Lógica:** 1) SELECT profiles, wallets FOR UPDATE. 2) Contar muertes previas en `avatar_deaths` WHERE recovered=true. 3) **Penalización BTC escalante — Constantes Maestras v2.0.0:** 1ª muerte→30%, 2ª→40%, 3ª+→50%. `btc_lost = FLOOR(wallet.btc_balance × penalty_pct)`. 4) **Degradación de vectores:** Todos los vectores pierden 80% de su valor (quedan al 20%) **EXCEPTO AURA que preserva 30%** (queda al 30% de su valor original). Es decir: `aura = aura × 0.30`, `jawline = jawline × 0.20`, `wealth = wealth × 0.20`, `physique = physique × 0.20`, `social = social × 0.20`, `env = 0` (reset). 5) **UPDATE wallets:** btc_balance -= btc_lost. Registrar en btc_transactions tipo 'death_penalty'. 6) **INSERT avatar_deaths:** death_number, btc_lost, vectors_before (JSONB snapshot), vectors_after, penalty_pct, is_hibernation. 7) **Si 3ª+ muerte → HIBERNACIÓN:** is_hibernation=true, hibernation_ends_at = NOW() + INTERVAL '72 hours'. Usuario NO puede generar/completar tareas durante hibernación. 8) **Reset HP:** current_hp = fn_calculate_hp_max(p_user_id) (full HP al revivir — si hibernación, HP se restaura después de las 72h). 9) streak = 0. 10) **INSERT notification** tipo 'avatar_death' con detalles de penalización. 11) **RETURN** `{"ok":true,"value":{"death_number":N,"btc_lost":N,"penalty_pct":N,"vectors_before":{...},"vectors_after":{...},"is_hibernation":bool,"hibernation_ends_at":"..." | null,"hp_restored_to":N}}`. | **Tests:** 1) 1ª muerte: BTC×0.30 perdido, AURA preserva 30%, resto al 20%, HP=max. 2) 2ª muerte: BTC×0.40. 3) 3ª muerte: BTC×0.50 + hibernación 72h. 4) AURA=100 → post-muerte=30.00. JAWLINE=100 → post-muerte=20.00. 5) streak=0. 6) Result monad `ok/value`. |  |  |
| 03.2.5.2 | Crear función `fn_check_hibernation_status` | [SQL] | Verifica si usuario está en hibernación. SECURITY DEFINER. Lógica: 1) Buscar en avatar_deaths el registro más reciente WHERE is_hibernation=true AND recovered=false. 2) Si existe y hibernation_ends_at > NOW() → en hibernación. 3) Si existe y hibernation_ends_at <= NOW() → hibernación terminada, marcar recovered=true, restaurar HP. 4) Si no existe → no está en hibernación. Retorna `{"ok":true,"value":{"is_hibernating":bool,"hibernation_ends_at":"..." | null,"hours_remaining":N | null,"death_number":N | null}}`. | Hibernación activa detectada. Hibernación expirada auto-recupera. Sin hibernación retorna is_hibernating=false. |
| 03.2.5.3 | Crear función `fn_recover_from_death` | [SQL] | Procesa recuperación post-muerte. SECURITY DEFINER. Lógica: 1) Verificar muerte no recuperada en avatar_deaths. 2) Si hibernación, verificar que hibernation_ends_at <= NOW(). 3) Marcar recovered=true, recovered_at=NOW(). 4) Restaurar HP: current_hp = fn_calculate_hp_max(p_user_id). 5) INSERT notification tipo 'avatar_recovered'. Retorna `{"ok":true,"value":{"recovered":true,"new_hp":N,"death_number":N}}`. | Recuperación exitosa. HP restaurado. Muerte marcada como recovered. |  |  |  |

---

## 03.2.6 — FUNCIÓN: DEGRADACIÓN DE VECTORES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.6.1 | Crear función `fn_apply_daily_vector_decay` | [SQL] | Aplica degradación diaria natural a vectores NO impactados positivamente. SECURITY DEFINER. **Constantes Maestras v2.0.0:** Tasa base: **-0.5** por vector no trabajado. Vectores ≤ 5.0 degradan a tasa reducida: **-0.25**. ENV (escala 0-20) degrada: **-0.1 por día**. Degradación nunca lleva un vector por debajo de 0.00. Lógica: 1) Obtener tareas completadas del día → extraer vectores impactados. 2) Para cada vector NO impactado: aplicar decay según reglas. `fn_clamp(valor - decay, 0, max)` donde max=100 para normales, 20 para ENV. 3) Recalcular overall_score y nivel. Si nivel bajó → INSERT level_history. Retorna `{"ok":true,"value":{"vectors_decayed":{"JAWLINE":-0.5,"WEALTH":-0.5},"new_overall":N}}`. | Vector no trabajado baja 0.5. Vector ≤5 baja 0.25. ENV baja 0.1. Vectores en 0 no bajan. Overall recalculado. |
| 03.2.6.2 | Crear función `fn_apply_inactivity_penalty` | [SQL] | Penalización acumulada por inactividad prolongada. SECURITY DEFINER. Reglas: 1-3 días inactivo→degradación normal. 4-7 días→degradación ×1.5. 8-14 días→degradación ×2.0. 15+ días→degradación ×3.0 + pérdida de 10% BTC. Lógica: Calcular días de inactividad desde último daily_log o last_active_at. Aplicar multiplicador a TODOS los vectores. Si ≥15 días: deducir 10% btc_balance, registrar btc_transaction. INSERT notification 'inactivity_penalty'. Retorna detalle de penalizaciones. | 5 días inactivo → decay ×1.5. 15 días → decay ×3.0 + 10% BTC perdido. |

---

## 03.2.7 — FUNCIÓN: GENERAR TAREAS DIARIAS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.7.1 | Crear función `fn_generate_daily_tasks` | [SQL] | Genera el set de tareas diarias. SECURITY DEFINER. **Función central del sistema de gamificación**. Parámetros: `p_user_id UUID, p_date DATE DEFAULT CURRENT_DATE`. Retorna JSONB Result Monad. **Pre-condiciones:** 1) Usuario existe y oath_taken=true. 2) No existen tareas para p_user_id + p_date. 3) No en hibernación. 4) Existe daily_log para fecha o crearlo con status='pending'. **Algoritmo:** 1) Obtener nivel actual → determina pool de dificultades. 2) Obtener herramientas equipadas → bonus de categoría. 3) Historial reciente (7 días) para evitar repetición excesiva. 4) Distribución por arquetipo según pesos de fn_get_task_categories_by_archetype. 5) **Número de tareas por nivel — Constantes Maestras v2.0.0:** INDIGENTE–MANTENIDO (index 0-2): **7 tareas**. ALUCÍN–HOMBRE COMÚN (3-5): **8 tareas**. INFLUYENTE–MILLONARIO (6-8): **9 tareas**. MAGNATE–SEMI-DIOS (9-11): **10 tareas**. 6) Para cada slot: seleccionar arquetipo ponderado → categoría sin repetición excesiva → asignar dificultad según nivel → calcular btc_reward y vector_impact → generar description placeholder. 7) INSERT daily_tasks con status='pending'. 8) Crear daily_log si no existe. Retorna `{"ok":true,"value":{"tasks_generated":N,"date":"...","task_ids":[...]}}`. | Lunes genera 7-10 tareas según nivel. Al menos 3 arquetipos representados. No duplicados (user_id, date, category). Hibernado → error. Sin oath → error. |
| 03.2.7.2 | Crear función `fn_enrich_task_with_ai_prompt` | [SQL] | Prepara payload para que Gemini 2.5 Flash genere descripción personalizada. SECURITY DEFINER. Parámetro: `p_task_id UUID`. **NO llama a Gemini directamente** — solo prepara el JSON con: task_context (category, difficulty, user_level, vectores, historial similar, herramientas equipadas), prompt_template, constraints (max_length:280, language:"es-MX", tone:"motivacional_masculino", must_be_actionable:true, must_include_metric:true). **Proveedor IA: Solo Gemini 2.5 Flash. [fal.ai](http://fal.ai) PROHIBIDO.** Retorna `{"ok":true,"value":{"prompt_payload":{...}}}`. | Payload JSON completo. NO contiene llamada HTTP. Proveedor = gemini. |
| 03.2.7.3 | Crear función `fn_validate_daily_task_limits` | [SQL] | Verifica que tareas generadas no excedan límites. SECURITY DEFINER. Validaciones: 1) No más de max_daily_count por categoría. 2) Suma btc_reward potencial ≤ fn_calculate_daily_cap. 3) Al menos 3 arquetipos representados. 4) No más de 2 tareas consecutivas del mismo arquetipo. 5) Si herramientas equipadas, al menos 1 tarea aprovecha category_affinity. Retorna `{"ok":true,"value":{"valid":true,"checks_passed":[...]}}` o `{"ok":false,"error":"...","violations":[...]}`. | Todas las validaciones pasan con set válido. Violaciones detectadas con set inválido. |

---

## 03.2.8 — FUNCIÓN: RECOMPENSA BTC (Centralizadas)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.8.1 | Crear función `fn_reward_btc` | [SQL] | Función centralizada para otorgar BTC. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_amount INTEGER, p_type TransactionType, p_description TEXT, p_metadata JSONB DEFAULT '{}'`. Validaciones: amount>0, si type='task_reward' verificar daily cap (**2,000 base**), no hibernación. Acciones: UPDATE wallets (btc_balance, total_btc_earned, btc_earned_today si aplica). INSERT btc_transactions. Retorna `{"ok":true,"value":{"new_balance":N,"amount_awarded":N,"capped":bool}}`. | Balance incrementa. Transacción registrada. Cap respetado (2000 base). |
| 03.2.8.2 | Crear función `fn_deduct_btc` | [SQL] | Función centralizada para deducir BTC. SECURITY DEFINER. Validaciones: amount>0, btc_balance >= amount (no saldo negativo). Acciones: UPDATE wallets (btc_balance). INSERT btc_transactions con amount negativo. Retorna `{"ok":true,"value":{"new_balance":N,"amount_deducted":N}}`. Error fondos insuficientes: `{"ok":false,"error":"INSUFFICIENT_FUNDS","current_balance":N,"required":N}`. | Balance decrementa. Saldo negativo rechazado con `ok:false`. |
| 03.2.8.3 | Crear función `fn_reset_daily_btc_counter` | [SQL] | Resetea btc_earned_today de todos los wallets. SECURITY DEFINER. Lógica: UPDATE wallets SET btc_earned_today=0 WHERE el timezone del usuario (profiles.timezone) indica nuevo día. **Invocada por Inngest cada hora** para cubrir zonas horarias. Retorna `{"ok":true,"value":{"wallets_reset":N}}`. | Wallets reseteados correctamente. Solo afecta usuarios cuyo día cambió. |
| 03.2.8.4 | Crear función `fn_calculate_btc_reward` | [SQL] | Función auxiliar pura que calcula reward BTC completo. Parámetros: `p_base_btc INTEGER, p_user_id UUID, p_health SMALLINT, p_repetition SMALLINT`. Fórmula: `FLOOR(p_base_btc × fn_calculate_btc_multiplier(p_user_id) × fn_get_health_penalty(p_health) × fn_get_diminishing_factor(p_repetition))`. **NOTA:** `fn_calculate_btc_multiplier` ya usa fórmula ADITIVA internamente. Retorna INTEGER. | base=100, multiplier=1.80, health=10(×1.0), rep=1(×1.0) → FLOOR(100×1.80×1.0×1.0) = 180. |

---

## 03.2.9 — FUNCIÓN: RECALCULAR ENV

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.9.1 | Crear función `fn_recalculate_env` | [SQL] | Recalcula vector ENV (escala 0-20) basado en condiciones actuales. SECURITY DEFINER. **Componentes — Constantes Maestras v2.0.0:** 1) **Streak** (0-5): `MIN(current_streak / 3, 5)`. 2) **Subscription** (0-5): sin sub→0, weekly→2, monthly→3, protocol_100→5. 3) **Tools** (0-5): `MIN(herramientas_equipadas × 1, 5)`. 4) **Consistency** (0-5): % días exitosos últimos 30 días. 0-20%→0, 21-40%→1, 41-60%→2, 61-80%→3, 81-95%→4, 96-100%→5. **Cálculo:** `ENV = fn_clamp(streak + subscription + tools + consistency, 0, 20)`. **Se invoca después de:** cada judgement, cambios de suscripción, equipar/desequipar herramientas. Retorna `{"ok":true,"value":{"new_env":N,"components":{"streak":N,"subscription":N,"tools":N,"consistency":N}}}`. | ENV escala 0-20 (NO 1-10 como versión anterior). Componentes suman correctamente. fn_clamp aplicado. |

---

## 03.2.10 — FUNCIÓN: TIENDA (Compra/Equipar/Desequipar)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.10.1 | Crear función `fn_purchase_item` | [SQL] | Transacción de compra. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_item_id TEXT, p_idempotency_key TEXT`. Retorna JSONB Result Monad. Validaciones: 1) Item existe en fn_get_tools_config(). 2) Usuario cumple level_required. 3) Balance suficiente. 4) No posee ya max permitido (inventario). 5) No en hibernación. Transacción: 1) fn_deduct_btc(p_user_id, price, 'purchase'). 2) INSERT/UPDATE inventory (quantity). 3) INSERT notification 'item_purchased'. Retorna `{"ok":true,"value":{"item_id":"...","new_balance":N,"quantity":N}}`. | Compra exitosa: balance baja, inventory crece. Balance insuficiente: `ok:false`. Nivel insuficiente: `ok:false`. Idempotencia funciona. |
| 03.2.10.2 | Crear función `fn_equip_item` | [SQL] | Equipar item del inventario. SECURITY DEFINER. Validaciones: item existe en inventory con quantity>0, max_stack respetado, límite total 3 herramientas equipadas simultáneamente. Acción: UPDATE inventory is_equipped=true, equipped_at=NOW(). Recalcular ENV vía fn_recalculate_env (tools component). Retorna `{"ok":true,"value":{"item_id":"...","equipped":true,"total_equipped":N}}`. | Item equipado. ENV recalculado. Límite 3 respetado. |
| 03.2.10.3 | Crear función `fn_unequip_item` | [SQL] | Desequipar item. SECURITY DEFINER. Validación: item existe y is_equipped=true. Acción: UPDATE is_equipped=false, equipped_at=NULL. Recalcular ENV. Retorna `{"ok":true,"value":{"item_id":"...","equipped":false,"total_equipped":N}}`. | Item desequipado. ENV recalculado. |
| 03.2.10.4 | Crear función `fn_get_store_catalog` | [SQL] | Catálogo completo personalizado. SECURITY DEFINER. Lógica: 1) Obtener herramientas de fn_get_tools_config(). 2) Para cada una: verificar level_required vs usuario, verificar si posee, verificar balance. 3) Estado: 'available', 'owned', 'locked_level', 'locked_funds'. **Rarities: 4 niveles (common, rare, epic, legendary — SIN 'uncommon').** Retorna JSONB array de herramientas con estado. | 9 herramientas. 4 rarities. Estado personalizado por usuario. |
| 03.2.10.5 | Crear función `fn_unlock_death_items` | [SQL] | Desbloquea items bloqueados por muerte (requiere pago BTC). SECURITY DEFINER. Parámetros: `p_user_id UUID, p_inventory_id UUID`. Lógica: 1) Verificar item locked_by_death=true. 2) Calcular unlock_cost (25% del precio original). 3) fn_deduct_btc. 4) UPDATE locked_by_death=false. Retorna `{"ok":true,"value":{"unlocked":true,"cost":N,"new_balance":N}}`. | Item desbloqueado. BTC deducidos. |

---

## 03.2.11 — FUNCIONES DE ONBOARDING

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.11.1 | Crear función `fn_complete_onboarding` | [SQL] | Completa onboarding: selecciona personaje e inicia protocolo. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_base_avatar_id SMALLINT, p_nickname TEXT, p_timezone TEXT, p_locale TEXT DEFAULT 'es-MX'`. Validaciones: base_avatar_id BETWEEN 1 AND 6 (**6 personajes: EL_RASTAS, EL_GUARRO, EL_PECAS, EL_GREÑAS, EL_GUERO, EL_LIC**). nickname no vacío. Lógica: 1) UPDATE profiles SET base_avatar_id, nickname, timezone, locale, oath_taken=true, onboarding_completed_at=NOW(). 2) Generar tareas del día 1: fn_generate_daily_tasks(p_user_id, CURRENT_DATE). 3) Encolar primera imagen: INSERT image_generation_queue con vectores en 0 y base_avatar_id. 4) INSERT notification 'welcome'. Retorna `{"ok":true,"value":{"profile_updated":true,"tasks_generated":N,"image_queued":true}}`. | base_avatar_id guardado (1-6). oath_taken=true. Tareas generadas. Imagen encolada. nickname guardado. |
| 03.2.11.2 | Verificar inmutabilidad de base_avatar_id | [MANUAL] | **Constantes Maestras v2.0.0**: La elección de personaje es inmutable durante el ciclo. Solo puede cambiarse tras muerte. Verificar que NO existe función que permita cambiar base_avatar_id fuera de fn_execute_avatar_death y fn_complete_onboarding. | No existe UPDATE a profiles.base_avatar_id fuera de funciones autorizadas. |

---

## 03.2.12 — FUNCIONES DE NIVEL Y HEALTH BONUS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.12.1 | Crear función `fn_get_level_health_bonus` | [SQL] | Retorna health_bonus al alcanzar un nivel. **12 niveles — Constantes Maestras v2.0.0**: Niveles con index 3(ALUCÍN), 6(INFLUYENTE), 9(MAGNATE) otorgan +1 HP max. Atributos: IMMUTABLE. | index=3→1, =6→1, =9→1, =5→0, =11→0. **Solo 3 niveles dan bonus, NO 4.** |
| 03.2.12.2 | Crear función `fn_get_level_btc_bonus` | [SQL] | Retorna BTC bonus one-time al subir de nivel. **12 niveles:** INDIGENTE(0)→0, REFUGIADO(1)→200, MANTENIDO(2)→500, ALUCÍN(3)→1000, PEÓN(4)→1500, HOMBRE COMÚN(5)→2000, INFLUYENTE(6)→2500, PUDIENTE(7)→3500, MILLONARIO(8)→5000, MAGNATE(9)→10000, ÉLITE(10)→20000, SEMI-DIOS(11)→50000. Atributos: IMMUTABLE. | Cada nivel retorna BTC correcto. **12 niveles, NO 13.** |
| 03.2.12.3 | Crear función `fn_process_level_up` | [SQL] | Procesa un level up completo. SECURITY DEFINER. Lógica: 1) Verificar que nuevo nivel > nivel anterior. 2) Aplicar health_bonus si aplica (fn_get_level_health_bonus). 3) Otorgar BTC bonus vía fn_reward_btc con type='level_up_bonus'. 4) INSERT level_history con nivel anterior, nuevo nivel, overall_score. 5) INSERT notification tipo 'level_up'. Retorna `{"ok":true,"value":{"old_level":"...","new_level":"...","hp_bonus":N,"btc_bonus":N}}`. | Level up procesado. HP incrementa si aplica. BTC bonus otorgado. Historial registrado. |

---

## 03.2.13 — FUNCIONES DE CLEANUP Y MANTENIMIENTO

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.13.1 | Crear función `fn_cleanup_expired_idempotency_keys` | [SQL] | Limpieza de keys expiradas. SECURITY DEFINER. Ejecutado por cron cada hora. Lógica: DELETE FROM idempotency_keys WHERE expires_at < NOW() AND status IN ('completed','failed'). Reset keys stuck: UPDATE SET status='failed' WHERE status='processing' AND created_at < NOW() - INTERVAL '5 minutes'. Retorna count de keys eliminadas. | Keys expiradas eliminadas. Keys stuck marcadas failed. |
| 03.2.13.2 | Crear función `fn_cleanup_old_notifications` | [SQL] | Limpieza de notificaciones antiguas leídas. SECURITY DEFINER. DELETE notifications WHERE is_read=true AND created_at < NOW() - INTERVAL '30 days'. Retorna count. | Notificaciones leídas >30 días eliminadas. |
| 03.2.13.3 | Crear función `fn_cleanup_old_activity_logs` | [SQL] | Limpieza de activity_logs antiguos. SECURITY DEFINER. DELETE activity_logs WHERE created_at < NOW() - INTERVAL '90 days'. Retorna count. | Logs >90 días eliminados. |

---

## 03.2.14 — FUNCIÓN: ESTADO COMPLETO DEL USUARIO

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.14.1 | Crear función `fn_get_user_full_state` | [SQL] | Estado completo en una sola query optimizada para dashboard. SECURITY DEFINER. Parámetro: `p_user_id UUID`. Lógica: 1) SELECT profiles (incluyendo nickname, phone_encrypted, oath_taken, timezone, locale, deleted_at). 2) SELECT vectores de profiles (aura, jawline, wealth, physique, social, env — **6 vectores escala 0-100/0-20**). 3) SELECT wallets (btc_balance, btc_earned_today, current_streak, current_hp, total_btc_earned — columna es **btc_balance NO balance**). 4) SELECT subscriptions (status, plan — **weekly/monthly/protocol_100**). 5) SELECT daily_tasks WHERE scheduled_date=CURRENT_DATE. 6) SELECT inventory WHERE is_equipped=true JOIN store_items. 7) SELECT notificaciones no leídas COUNT. Retorna JSONB con 7 secciones: profile, vectors, wallet, subscription, today_tasks, equipped_items, unread_notifications_count. | JSONB con 7 secciones. 6 vectores presentes. wallet usa btc_balance (NO balance). Planes correctos. nickname incluido en profile. |
| 03.2.14.2 | Crear función `fn_get_user_history` | [SQL] | Historial resumido para pantalla de progreso. SECURITY DEFINER. Parámetro: `p_user_id UUID, p_days INTEGER DEFAULT 30`. Retorna últimos N daily_logs con snapshots de vectores, streak history, level_history, btc_transactions summary. Optimizado con LIMIT y ORDER BY date DESC. | Historial de 30 días. Snapshots incluyen 6 vectores. |

---

## 03.2.15 — FUNCIÓN: GENERAR PROMPT DE IMAGEN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.15.1 | Crear función `fn_build_image_prompt` | [SQL] | Construye prompt completo para generación de avatar IA. SECURITY DEFINER. Parámetro: `p_user_id UUID`. Retorna TEXT. Lógica: 1) Obtener base_avatar_id de profiles (**6 personajes, IDs 1-6**). 2) Obtener 6 vectores + HP. 3) Obtener items equipados con ia_token. 4) Construir prompt: STYLE_HEADER + IDENTITY_ANCHOR[base_avatar_id] + tokens por cada vector según rango + items tokens + ENV token + HEALTH token. Tokens indexados en intervalos de rango del vector. **Proveedor: Gemini 2.5 Flash ÚNICAMENTE. [fal.ai](http://fal.ai) PROHIBIDO.** | Prompt contiene identity anchor correcto (1-6). Refleja 6 vectores. Incluye items equipados. NO contiene referencia a [fal.ai](http://fal.ai). |
| 03.2.15.2 | Crear función `fn_queue_image_generation` | [SQL] | Encola generación de imagen. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_trigger TEXT, p_priority SMALLINT DEFAULT 5`. Lógica: 1) Generar prompt vía fn_build_image_prompt. 2) Snapshot de vectores actuales. 3) INSERT image_generation_queue con provider='**gemini**' (NO 'fal-ai'), status='pending'. 4) **Storage destino: Supabase Storage** (NO Cloudflare R2). Retorna `{"ok":true,"value":{"queue_id":"...","priority":N}}`. | Imagen encolada. provider='gemini'. Storage=Supabase Storage. |

---

## 03.2.16 — FUNCIONES DE PERFIL Y CONFIGURACIÓN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.16.1 | Crear función `fn_update_profile` | [SQL] | Actualiza campos editables del perfil. SECURITY DEFINER. Campos permitidos: nickname, phone_encrypted, timezone, locale. **Restricción timezone:** timezone_changed_at debe tener al menos 24h de diferencia con NOW() para permitir cambio (previene abuse de timezone para duplicar recompensas diarias). Retorna `{"ok":true,"value":{"updated_fields":[...]}}`. | Campos actualizados. Cambio de timezone rechazado si <24h desde último cambio. |
| 03.2.16.2 | Crear función `fn_soft_delete_account` | [SQL] | Soft delete de cuenta. SECURITY DEFINER. Lógica: UPDATE profiles SET deleted_at=NOW(). No elimina datos, solo marca. El usuario puede recuperar dentro de 30 días. Retorna `{"ok":true,"value":{"deleted_at":"..."}}`. | deleted_at populado. Datos preservados. |

---

## 03.2.17 — FUNCIONES DE NOTIFICACIONES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.17.1 | Crear función `fn_create_notification` | [SQL] | Crea notificación tipada. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_type NotificationType, p_title TEXT, p_body TEXT, p_metadata JSONB DEFAULT '{}'`. **10 tipos — Constantes Maestras v2.0.0:** task_reminder, streak_at_risk, death_warning, level_up, item_unlocked, daily_summary, judgement_success, judgement_failed, avatar_death, avatar_recovered. INSERT notifications. Retorna `{"ok":true,"value":{"notification_id":"..."}}`. | Notificación creada. type acepta 10 valores (NO 7 como antes). |
| 03.2.17.2 | Crear función `fn_mark_notifications_read` | [SQL] | Marca notificaciones como leídas en batch. SECURITY DEFINER. Parámetro: `p_user_id UUID, p_notification_ids UUID[] DEFAULT NULL`. Si NULL → marcar TODAS como leídas. Si array → marcar solo las indicadas. UPDATE notifications SET is_read=true, read_at=NOW(). Retorna count. | Notificaciones marcadas como leídas. |

---

## 03.2.18 — FUNCIONES DE SUSCRIPCIÓN Y PAGOS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.2.18.1 | Crear función `fn_process_subscription_change` | [SQL] | Procesa cambio de suscripción desde webhook Stripe. SECURITY DEFINER. Parámetros: `p_user_id UUID, p_plan TEXT, p_status TEXT, p_stripe_subscription_id TEXT, p_current_period_start TIMESTAMPTZ, p_current_period_end TIMESTAMPTZ`. **Planes válidos: 'weekly' ($2.99), 'monthly' ($9.99), 'protocol_100' ($29.99). NO existe 'yearly' ni 'annual'.** Lógica: 1) UPDATE subscriptions con datos de Stripe. 2) Si upgrade a protocol_100 → recalcular HP max (fn_calculate_hp_max) y daily cap (fn_calculate_daily_cap). 3) Recalcular ENV (fn_recalculate_env — subscription component cambia). 4) INSERT notification. Retorna `{"ok":true,"value":{"plan":"...","status":"...","new_hp_max":N,"new_daily_cap":N}}`. | Suscripción actualizada. HP max y daily cap recalculados. ENV recalculado. **NO acepta plan 'yearly'.** |
| 03.2.18.2 | Crear función `fn_process_trial_expiration` | [SQL] | Procesa expiración de trial. SECURITY DEFINER. Invocada por cron. Lógica: SELECT subscriptions WHERE status='trial' AND trial_end <= NOW(). UPDATE status='cancelled' si no hay Stripe payment method. INSERT notification 'trial_expired'. Retorna count de trials expirados. | Trials expirados marcados. Notificaciones enviadas. |
| 03.2.18.3 | Crear función `fn_handle_payment_failed` | [SQL] | Procesa pago fallido desde webhook Stripe. SECURITY DEFINER. Lógica: UPDATE subscriptions SET status='limbo'. INSERT notification 'payment_failed' con instrucciones. Si >3 pagos fallidos consecutivos → UPDATE status='cancelled'. Retorna `{"ok":true,"value":{"new_status":"...","consecutive_failures":N}}`. | Suscripción en limbo. Después de 3 fallos → cancelled. |


# ══════════════════════════════════════════════════════════════

# SUBCAJA 03.3 — RLS POLICIES

# Row Level Security · Policies por Tabla · Verificación Global

# 45 TAREAS (vs 33 original)

# ══════════════════════════════════════════════════════════════

---

## 03.3.1 — HABILITAR RLS EN TODAS LAS TABLAS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.1.1 | Habilitar RLS en `profiles` | [SQL] | `ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;` — Cada usuario solo puede ver y editar su propio perfil. Incluye campos sensibles: nickname, phone_encrypted, oath_taken, timezone_changed_at, locale, deleted_at. | `SELECT relrowsecurity FROM pg_class WHERE relname = 'profiles'` devuelve TRUE. |
| 03.3.1.2 | Habilitar RLS en `wallets` | [SQL] | `ALTER TABLE wallets ENABLE ROW LEVEL SECURITY;` — Protege btc_balance, btc_earned_today, current_streak, current_hp. **Columna es btc_balance (NO balance).** | relrowsecurity = TRUE. |
| 03.3.1.3 | Habilitar RLS en `subscriptions` | [SQL] | `ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;` — Protege plan, status, datos de Stripe. **Planes válidos: weekly, monthly, protocol_100 (NO yearly).** | relrowsecurity = TRUE. |
| 03.3.1.4 | Habilitar RLS en `daily_tasks` | [SQL] | `ALTER TABLE daily_tasks ENABLE ROW LEVEL SECURITY;` — Protege tareas diarias. Las 17 categorías son visibles solo al propietario. | relrowsecurity = TRUE. |
| 03.3.1.5 | Habilitar RLS en `daily_logs` | [SQL] | `ALTER TABLE daily_logs ENABLE ROW LEVEL SECURITY;` — Protege historial de Judgement Night y snapshots de 6 vectores. **Judgement es BINARIO (success/failed/death, SIN partial).** | relrowsecurity = TRUE. |
| 03.3.1.6 | Habilitar RLS en `store_items` | [SQL] | `ALTER TABLE store_items ENABLE ROW LEVEL SECURITY;` — Catálogo visible para todos los autenticados, solo admin puede modificar. **Rarities: 4 niveles (common, rare, epic, legendary — SIN 'uncommon').** | relrowsecurity = TRUE. |
| 03.3.1.7 | Habilitar RLS en `inventory` | [SQL] | `ALTER TABLE inventory ENABLE ROW LEVEL SECURITY;` — Protege items del usuario, incluyendo locked_by_death. | relrowsecurity = TRUE. |
| 03.3.1.8 | Habilitar RLS en `tool_progress` | [SQL] | `ALTER TABLE tool_progress ENABLE ROW LEVEL SECURITY;` — Protege progreso de las 9 herramientas. | relrowsecurity = TRUE. |
| 03.3.1.9 | Habilitar RLS en `activity_logs` | [SQL] | `ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;` — Logs de auditoría solo visibles al propietario. | relrowsecurity = TRUE. |
| 03.3.1.10 | Habilitar RLS en `image_generation_queue` | [SQL] | `ALTER TABLE image_generation_queue ENABLE ROW LEVEL SECURITY;` — Cola de generación con provider='**gemini**' (NO 'fal-ai'). **Storage: Supabase Storage (NO R2).** | relrowsecurity = TRUE. |
| 03.3.1.11 | Habilitar RLS en `notifications` | [SQL] | `ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;` — **10 tipos de notificación** (NO 7 como versión anterior). | relrowsecurity = TRUE. |
| 03.3.1.12 | Habilitar RLS en `idempotency_keys` | [SQL] | `ALTER TABLE idempotency_keys ENABLE ROW LEVEL SECURITY;` — Prevención de double-clicks (ADR-003). | relrowsecurity = TRUE. |
| 03.3.1.13 | Habilitar RLS en `payments` | [SQL] | `ALTER TABLE payments ENABLE ROW LEVEL SECURITY;` — Registros de pago Stripe sensibles. | relrowsecurity = TRUE. |
| 03.3.1.14 | Habilitar RLS en `btc_transactions` | [SQL] | `ALTER TABLE btc_transactions ENABLE ROW LEVEL SECURITY;` — **Tabla nueva v2.0.0**: historial de transacciones BTC (rewards, purchases, penalties). | relrowsecurity = TRUE. |
| 03.3.1.15 | Habilitar RLS en `level_history` | [SQL] | `ALTER TABLE level_history ENABLE ROW LEVEL SECURITY;` — **Tabla nueva v2.0.0**: historial de cambios de nivel. **12 niveles (NO 13).** | relrowsecurity = TRUE. |
| 03.3.1.16 | Habilitar RLS en `avatar_deaths` | [SQL] | `ALTER TABLE avatar_deaths ENABLE ROW LEVEL SECURITY;` — **Tabla nueva v2.0.0**: registro de muertes, hibernaciones, penalizaciones. | relrowsecurity = TRUE. |

---

## 03.3.2 — POLICIES: PROFILES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.2.1 | Policy SELECT en `profiles` | [SQL] | `CREATE POLICY "profiles_select_own" ON profiles FOR SELECT USING (auth.uid() = id);` — Usuarios solo ven su propio perfil. Campos visibles: id, email, nickname, base_avatar_id, oath_taken, timezone, locale, onboarding_completed_at, created_at, updated_at. **NO expone phone_encrypted al SELECT directo** (se accede vía función SECURITY DEFINER si se necesita). | Usuario A no puede SELECT perfil de usuario B. |
| 03.3.2.2 | Policy UPDATE en `profiles` | [SQL] | `CREATE POLICY "profiles_update_own" ON profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);` — Campos editables por el client: nickname, timezone, locale. **Campos NO editables directamente:** base_avatar_id (solo vía fn_complete_onboarding / fn_execute_avatar_death), oath_taken (solo vía fn_complete_onboarding), phone_encrypted (solo vía fn_update_profile que valida formato), deleted_at (solo vía fn_soft_delete_account), timezone_changed_at (solo vía fn_update_profile que valida cooldown 24h). | Usuario A no puede UPDATE perfil de B. UPDATE de nickname funciona. |
| 03.3.2.3 | Policy INSERT en `profiles` | [SQL] | `CREATE POLICY "profiles_insert_self" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);` — Solo puede crear su propio perfil. El trigger fn_handle_new_user usa SECURITY DEFINER y bypasea RLS, por lo que esta policy es de respaldo. | INSERT con id diferente a auth.uid() falla desde client. |

---

## 03.3.3 — POLICIES: WALLETS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.3.1 | Policy SELECT en `wallets` | [SQL] | `CREATE POLICY "wallets_select_own" ON wallets FOR SELECT USING (auth.uid() = user_id);` — Solo ver propia wallet. Columnas visibles: btc_balance (**NO 'balance'**), btc_earned_today, total_btc_earned, current_streak, longest_streak, current_hp, daily_cap (default **2,000** NO 3,500). | Solo ver propia wallet. |
| 03.3.3.2 | Policy UPDATE en `wallets` (DENEGADA a client) | [SQL] | **NO crear policy de UPDATE para rol authenticated.** Wallets SOLO se modifican vía SECURITY DEFINER functions: fn_complete_task_transaction, fn_reward_btc, fn_deduct_btc, fn_execute_avatar_death, fn_reset_daily_btc_counter. Esto previene manipulación directa de btc_balance, current_hp, current_streak desde el cliente. | `UPDATE wallets SET btc_balance = 999999 WHERE user_id = auth.uid()` desde client FALLA con "new row violates row-level security policy". |

---

## 03.3.4 — POLICIES: SUBSCRIPTIONS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.4.1 | Policy SELECT en `subscriptions` | [SQL] | `CREATE POLICY "subscriptions_select_own" ON subscriptions FOR SELECT USING (auth.uid() = user_id);` — Solo ver propia suscripción. Campos visibles incluyen plan (**weekly/monthly/protocol_100 — NO yearly**), status, trial_end, current_period_end. | Solo ver propia suscripción. |
| 03.3.4.2 | Policy UPDATE en `subscriptions` (DENEGADA a client) | [SQL] | **NO crear policy de UPDATE.** Subscriptions se modifican SOLO vía: webhooks Stripe (service_role key), fn_process_subscription_change, fn_process_trial_expiration, fn_handle_payment_failed. Todas son SECURITY DEFINER. | UPDATE directo desde client FALLA. |

---

## 03.3.5 — POLICIES: DAILY_TASKS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.5.1 | Policy SELECT en `daily_tasks` | [SQL] | `CREATE POLICY "daily_tasks_select_own" ON daily_tasks FOR SELECT USING (auth.uid() = user_id);` — Ver solo propias tareas. Las 17 categorías son visibles pero solo las del usuario autenticado. Incluye campos: status (**4 estados: pending, in_progress, completed, failed — NO 'skipped'**), btc_earned, vector_changes JSONB. | Usuario solo ve sus tareas. |
| 03.3.5.2 | Policy UPDATE en `daily_tasks` (DENEGADA a client) | [SQL] | **NO crear policy de UPDATE directo.** Tareas se gestionan SOLO vía SECURITY DEFINER functions: fn_complete_task_transaction (completar), fn_start_task (iniciar), fn_fail_task (fallar). Esto previene marcar tareas como completadas sin pasar por la lógica de vectores, BTC multiplicador aditivo y validaciones de daily cap (2,000). | UPDATE directo desde client FALLA. |
| 03.3.5.3 | Policy INSERT en `daily_tasks` (DENEGADA a client) | [SQL] | **NO crear policy de INSERT.** Tareas se generan SOLO vía fn_generate_daily_tasks (SECURITY DEFINER). El usuario NO puede crear tareas manualmente. | INSERT directo desde client FALLA. |

---

## 03.3.6 — POLICIES: DAILY_LOGS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.6.1 | Policy SELECT en `daily_logs` | [SQL] | `CREATE POLICY "daily_logs_select_own" ON daily_logs FOR SELECT USING (auth.uid() = user_id);` — Historial solo visible al propietario. Los snapshots JSONB contienen 6 vectores (**aura, jawline, wealth, physique, social, env**). day_status usa **3 valores: success, failed, death (SIN 'partial')**. | Solo ver propios logs. |
| 03.3.6.2 | Policy INSERT/UPDATE en `daily_logs` (DENEGADA) | [SQL] | **NO crear policies de INSERT ni UPDATE.** daily_logs se crean y modifican SOLO vía fn_generate_daily_tasks (crear), fn_complete_task_transaction (actualizar counters), fn_process_judgement_night (cerrar día). | INSERT y UPDATE directos desde client FALLAN. |

---

## 03.3.7 — POLICIES: STORE_ITEMS (Catálogo Público)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.7.1 | Policy SELECT en `store_items` (pública autenticada) | [SQL] | `CREATE POLICY "store_items_select_authenticated" ON store_items FOR SELECT USING (auth.role() = 'authenticated' AND is_active = TRUE);` — Catálogo visible para todos los usuarios autenticados, solo items activos. **4 rarities visibles: common, rare, epic, legendary (SIN 'uncommon').** 9 herramientas. | Cualquier usuario autenticado ve items activos. Items is_active=FALSE no visibles. Usuarios no autenticados no ven nada. |
| 03.3.7.2 | Policy INSERT/UPDATE/DELETE en `store_items` (solo service_role) | [SQL] | **NO crear policies de INSERT, UPDATE ni DELETE para authenticated.** El catálogo se administra SOLO con service_role key (admin). Esto previene que usuarios modifiquen precios, niveles requeridos, o creen items falsos. | INSERT/UPDATE/DELETE desde client FALLAN. Solo service_role puede modificar catálogo. |

---

## 03.3.8 — POLICIES: INVENTORY

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.8.1 | Policy SELECT en `inventory` | [SQL] | `CREATE POLICY "inventory_select_own" ON inventory FOR SELECT USING (auth.uid() = user_id);` — Solo ver propio inventario. Campos visibles: item_id, is_equipped, equipped_at, locked_by_death, quantity. | Solo ver propio inventario. |
| 03.3.8.2 | Policy UPDATE en `inventory` (DENEGADA a client) | [SQL] | **NO crear policy de UPDATE directo.** A diferencia de la versión anterior que permitía toggle de equip desde client, ahora equipar/desequipar se maneja SOLO vía fn_equip_item y fn_unequip_item (SECURITY DEFINER) porque estos recalculan ENV automáticamente. Si el client pudiera hacer UPDATE directo, podría equipar sin recalcular ENV, causando inconsistencias. | UPDATE directo desde client FALLA. |
| 03.3.8.3 | Policy INSERT en `inventory` (DENEGADA) | [SQL] | **NO crear policy INSERT.** Items se agregan al inventario SOLO vía fn_purchase_item (SECURITY DEFINER). | INSERT directo FALLA. |

---

## 03.3.9 — POLICIES: TOOL_PROGRESS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.9.1 | Policy SELECT en `tool_progress` | [SQL] | `CREATE POLICY "tool_progress_select_own" ON tool_progress FOR SELECT USING (auth.uid() = user_id);` — Ver progreso de las 9 herramientas propias: GOLDEN_RAZOR, POWER_SHAKE, CHARM_COLOGNE, BRAIN_SERUM, STREET_CRED_CARD, COLD_SHOWER_TIMER, MUSCLE_BANDS, VISION_BOARD, GRIND_PLAYLIST. | Solo ver propios registros de 9 herramientas. |
| 03.3.9.2 | Policy UPDATE en `tool_progress` (DENEGADA) | [SQL] | **NO crear policy UPDATE.** tool_progress se actualiza SOLO vía fn_complete_task_transaction (SECURITY DEFINER) cuando una tarea con herramienta asociada se completa. | UPDATE directo FALLA. |

---

## 03.3.10 — POLICIES: ACTIVITY_LOGS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.10.1 | Policy SELECT en `activity_logs` | [SQL] | `CREATE POLICY "activity_logs_select_own" ON activity_logs FOR SELECT USING (auth.uid() = user_id);` — Solo ver propios logs de actividad. | Solo ver propios logs. |
| 03.3.10.2 | Policy INSERT/UPDATE/DELETE en `activity_logs` (DENEGADA) | [SQL] | **NO crear policies de escritura.** activity_logs se insertan SOLO vía SECURITY DEFINER functions. Los logs son append-only: no se modifican ni eliminan desde client (cleanup vía fn_cleanup_old_activity_logs con service_role). | Escritura directa desde client FALLA. |

---

## 03.3.11 — POLICIES: IMAGE_GENERATION_QUEUE

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.11.1 | Policy SELECT en `image_generation_queue` | [SQL] | `CREATE POLICY "image_queue_select_own" ON image_generation_queue FOR SELECT USING (auth.uid() = user_id);` — Usuarios pueden ver el status de sus imágenes en cola. Campos visibles incluyen status (**5 estados: pending, processing, completed, failed, retrying** — 'retrying' es nuevo en v2.0.0), result_url (apunta a **Supabase Storage**, NO R2), provider (siempre '**gemini**', NO 'fal-ai'). | Solo ver propias imágenes. provider siempre 'gemini'. |
| 03.3.11.2 | Policy INSERT/UPDATE en `image_generation_queue` (DENEGADA) | [SQL] | **NO crear policies de escritura.** La cola se gestiona SOLO vía: fn_queue_image_generation (INSERT), worker de Inngest vía service_role (UPDATE status/result). El client NO puede encolar imágenes directamente ni modificar status. | Escritura directa desde client FALLA. |

---

## 03.3.12 — POLICIES: NOTIFICATIONS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.12.1 | Policy SELECT en `notifications` | [SQL] | `CREATE POLICY "notifications_select_own" ON notifications FOR SELECT USING (auth.uid() = user_id);` — Solo ver propias notificaciones. **10 tipos** de notificación (v2.0.0): task_reminder, streak_at_risk, death_warning, level_up, item_unlocked, daily_summary, judgement_success, judgement_failed, avatar_death, avatar_recovered. | Solo ver propias notificaciones. 10 tipos aceptados. |
| 03.3.12.2 | Policy UPDATE en `notifications` (marcar leída) | [SQL] | `CREATE POLICY "notifications_update_read" ON notifications FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);` — Permite al client marcar notificaciones como leídas (is_read=TRUE, read_at=NOW()). **NOTA:** Esta es una de las POCAS policies UPDATE permitidas al client, porque marcar como leída no afecta estado del juego. | UPDATE is_read funciona en propias notificaciones. No puede modificar type, title, body ni metadata. |
| 03.3.12.3 | Policy INSERT en `notifications` (DENEGADA) | [SQL] | **NO crear policy INSERT.** Notificaciones se crean SOLO vía fn_create_notification (SECURITY DEFINER). El client NO puede crear notificaciones falsas. | INSERT directo FALLA. |

---

## 03.3.13 — POLICIES: IDEMPOTENCY_KEYS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.13.1 | Policy SELECT en `idempotency_keys` | [SQL] | `CREATE POLICY "idempotency_select_own" ON idempotency_keys FOR SELECT USING (auth.uid() = user_id);` — Client puede verificar si una key ya fue procesada (para retry logic). | Solo ver propias keys. |
| 03.3.13.2 | Policy INSERT/UPDATE en `idempotency_keys` (DENEGADA) | [SQL] | **NO crear policies de escritura.** Idempotency keys se gestionan SOLO vía SECURITY DEFINER functions (fn_complete_task_transaction, fn_purchase_item). El cleanup se hace vía fn_cleanup_expired_idempotency_keys con service_role. | Escritura directa FALLA. |

---

## 03.3.14 — POLICIES: PAYMENTS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.14.1 | Policy SELECT en `payments` | [SQL] | `CREATE POLICY "payments_select_own" ON payments FOR SELECT USING (auth.uid() = user_id);` — Historial de pagos visible al propietario. Campos: amount_cents, currency, status, plan (**weekly/monthly/protocol_100**). | Solo ver propios pagos. |
| 03.3.14.2 | Policy INSERT/UPDATE en `payments` (DENEGADA) | [SQL] | **NO crear policies de escritura.** Payments se registran SOLO vía webhooks de Stripe (service_role key). | Escritura directa FALLA. |

---

## 03.3.15 — POLICIES: BTC_TRANSACTIONS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.15.1 | Policy SELECT en `btc_transactions` | [SQL] | `CREATE POLICY "btc_transactions_select_own" ON btc_transactions FOR SELECT USING (auth.uid() = user_id);` — Historial de transacciones BTC visible al propietario. Tipos: task_reward, level_up_bonus, purchase, death_penalty, inactivity_penalty. metadata JSONB incluye detalles del cálculo (multiplicador **aditivo**, base_btc, cap aplicado). | Solo ver propias transacciones. |
| 03.3.15.2 | Policy INSERT/UPDATE en `btc_transactions` (DENEGADA) | [SQL] | **NO crear policies de escritura.** Transacciones se registran SOLO vía fn_reward_btc y fn_deduct_btc (SECURITY DEFINER). Son append-only. | Escritura directa FALLA. |

---

## 03.3.16 — POLICIES: LEVEL_HISTORY

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.16.1 | Policy SELECT en `level_history` | [SQL] | `CREATE POLICY "level_history_select_own" ON level_history FOR SELECT USING (auth.uid() = user_id);` — Historial de niveles visible al propietario. **12 niveles**: INDIGENTE→REFUGIADO→MANTENIDO→ALUCÍN→PEÓN→HOMBRE COMÚN→INFLUYENTE→PUDIENTE→MILLONARIO→MAGNATE→ÉLITE→SEMI-DIOS. | Solo ver propio historial. Niveles correctos (12, NO 13). |
| 03.3.16.2 | Policy INSERT/UPDATE en `level_history` (DENEGADA) | [SQL] | **NO crear policies de escritura.** Historial se registra SOLO vía fn_process_level_up y fn_complete_task_transaction (SECURITY DEFINER). | Escritura directa FALLA. |

---

## 03.3.17 — POLICIES: AVATAR_DEATHS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.17.1 | Policy SELECT en `avatar_deaths` | [SQL] | `CREATE POLICY "avatar_deaths_select_own" ON avatar_deaths FOR SELECT USING (auth.uid() = user_id);` — Historial de muertes visible al propietario. Campos: death_number, btc_lost, penalty_pct (**1ª=30%, 2ª=40%, 3ª+=50%**), vectors_before/after JSONB, is_hibernation, hibernation_ends_at (**72 horas**), recovered, recovered_at. AURA preservada al **30%** en cada muerte. | Solo ver propias muertes. |
| 03.3.17.2 | Policy INSERT/UPDATE en `avatar_deaths` (DENEGADA) | [SQL] | **NO crear policies de escritura.** Muertes se registran SOLO vía fn_execute_avatar_death. Recuperaciones vía fn_recover_from_death y fn_check_hibernation_status. Todos SECURITY DEFINER. | Escritura directa FALLA. |

---

## 03.3.18 — VERIFICACIÓN GLOBAL DE RLS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.3.18.1 | Verificar que TODAS las tablas tienen RLS habilitado | [MANUAL] | Ejecutar: `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public' AND tablename IN ('profiles', 'wallets', 'subscriptions', 'daily_tasks', 'daily_logs', 'store_items', 'inventory', 'tool_progress', 'activity_logs', 'image_generation_queue', 'notifications', 'idempotency_keys', 'payments', 'btc_transactions', 'level_history', 'avatar_deaths');` — Las **16 tablas** deben tener rowsecurity=TRUE. **(vs 14 en versión anterior: se agregaron btc_transactions, level_history, avatar_deaths).** | 16 filas, todas con rowsecurity=TRUE. |
| 03.3.18.2 | Verificar tablas críticas SIN UPDATE policy para authenticated | [MANUAL] | Tablas que NO deben tener policy FOR UPDATE con rol authenticated: `wallets`, `subscriptions`, `daily_tasks`, `daily_logs`, `tool_progress`, `activity_logs`, `image_generation_queue`, `idempotency_keys`, `payments`, `btc_transactions`, `level_history`, `avatar_deaths`, `store_items`, `inventory`. Ejecutar: `SELECT tablename, policyname, cmd FROM pg_policies WHERE schemaname = 'public' AND cmd = 'UPDATE' AND tablename IN ('wallets','subscriptions','daily_tasks','daily_logs','tool_progress','activity_logs','image_generation_queue','idempotency_keys','payments','btc_transactions','level_history','avatar_deaths','store_items','inventory');` — Debe retornar **0 filas**. | 0 filas. Ninguna policy UPDATE en tablas críticas. |
| 03.3.18.3 | Verificar tablas con UPDATE policy permitida | [MANUAL] | Solo **2 tablas** deben tener policy UPDATE para authenticated: `profiles` (editar nickname, timezone, locale) y `notifications` (marcar como leída). Ejecutar: `SELECT tablename, policyname FROM pg_policies WHERE schemaname = 'public' AND cmd = 'UPDATE' AND tablename IN ('profiles', 'notifications');` — Debe retornar exactamente **2 filas**. | 2 filas: profiles_update_own, notifications_update_read. |
| 03.3.18.4 | Verificar que SECURITY DEFINER functions bypasean RLS | [MANUAL] | Las funciones SECURITY DEFINER (fn_complete_task_transaction, fn_process_judgement_night, fn_execute_avatar_death, fn_purchase_item, fn_equip_item, fn_unequip_item, fn_reward_btc, fn_deduct_btc, fn_generate_daily_tasks, fn_complete_onboarding, fn_recalculate_env, fn_process_subscription_change, fn_handle_new_user, etc.) deben poder hacer INSERT/UPDATE en tablas protegidas sin ser bloqueadas por RLS. **Verificar:** Llamar fn_complete_task_transaction desde un client autenticado → debe poder UPDATE wallets, daily_tasks, profiles, btc_transactions, activity_logs sin error de RLS. | Funciones SECURITY DEFINER ejecutan sin error RLS en todas las tablas que necesitan. |
| 03.3.18.5 | Verificar aislamiento entre usuarios | [MANUAL] | **Test de aislamiento cruzado:** Crear 2 usuarios de prueba (A y B). Desde sesión de A: 1) `SELECT * FROM profiles WHERE id = B.id` → 0 filas. 2) `SELECT * FROM wallets WHERE user_id = B.id` → 0 filas. 3) `SELECT * FROM daily_tasks WHERE user_id = B.id` → 0 filas. 4) `SELECT * FROM btc_transactions WHERE user_id = B.id` → 0 filas. 5) `SELECT * FROM notifications WHERE user_id = B.id` → 0 filas. Repetir desde sesión de B contra datos de A. | 0 filas en cada query cruzada. Aislamiento completo entre usuarios. |

---
# ══════════════════════════════════════════════════════════════

# SUBCAJA 03.4 — TYPES & SUPABASE CLIENTS (TypeScript)

# Tipos Compartidos · Branded Types · Result Monad · 4 Clients · Zod Schemas

# 42 TAREAS (vs 28 original)

# ══════════════════════════════════════════════════════════════

---

## 03.4.1 — SUPABASE CLIENTS (4 variantes + barrel)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.4.1.1 | Crear Supabase Client: Browser (Client Component) | [TYPESCRIPT] | Archivo: `src/lib/supabase/client-browser.ts`. Usa `createBrowserClient` de `@supabase/ssr`. Variables: `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`. Se usa en Client Components (`'use client'`) para suscripciones realtime y queries desde el browser. Exportar función `createBrowserSupabaseClient()` que retorna el client tipado con `Database` generado por Supabase CLI. El tipo `Database` se importa de `@/lib/core/types/database.types.ts` (generado automáticamente). | Client se crea sin errores. Puede hacer queries con RLS (auth.uid()). Tipo Database aplicado correctamente — autocompletado de tablas funciona. |
| 03.4.1.2 | Crear Supabase Client: Server (Server Component / Server Action) | [TYPESCRIPT] | Archivo: `src/lib/supabase/client-server.ts`. Usa `createServerClient` de `@supabase/ssr` con cookies de **Next.js 15** (async cookies). `import { cookies } from 'next/headers';` — **IMPORTANTE:** en Next.js 15 `cookies()` es async, usar `const cookieStore = await cookies();`. Implementar getAll() y setAll() con cookieStore. Tipar con `Database`. Se usa en Server Components, Server Actions y Route Handlers. | Client creado con cookies async de Next.js 15. auth.getUser() funciona. Sesión obtenida correctamente. |
| 03.4.1.3 | Crear Supabase Client: Service Role (Admin) | [TYPESCRIPT] | Archivo: `src/lib/supabase/client-admin.ts`. Usa `createClient` de `@supabase/supabase-js` con `SUPABASE_SERVICE_ROLE_KEY`. Bypasea RLS completamente. Config: `auth: { autoRefreshToken: false, persistSession: false }`. **SOLO para:** webhooks Stripe, cron jobs de Inngest, fn_process_judgement_batch, fn_reset_daily_btc_counter, workers de image_generation_queue. **NUNCA exponer al client ni importar en Client Components.** | Client funciona con service_role. SELECT/UPDATE sin RLS. Verificar que NO se importa en ningún archivo con `'use client'`. |
| 03.4.1.4 | Crear Supabase Client: Middleware | [TYPESCRIPT] | Archivo: `src/lib/supabase/client-middleware.ts`. Para uso en `middleware.ts` de Next.js 15. Recibe `NextRequest`, retorna `{ supabase, response }`. Implementar cookie handling con `request.cookies.getAll()` y `response.cookies.set()`. Se usa para refrescar sesión de Supabase Auth en cada request. | Client funciona dentro de middleware.ts. Refresca sesión correctamente. Response cookies propagadas. |
| 03.4.1.5 | Crear barrel export de Supabase clients | [TYPESCRIPT] | Archivo: `src/lib/supabase/index.ts`. Exportar los 4 clients: `export { createBrowserSupabaseClient } from './client-browser';` `export { createServerSupabaseClient } from './client-server';` `export { createAdminSupabaseClient } from './client-admin';` `export { createMiddlewareSupabaseClient } from './client-middleware';` | Imports funcionan desde barrel. Cada client accesible con una sola importación. |

---

## 03.4.2 — RESULT MONAD & ERROR HANDLING

| ID | Título | Tipo | Detalle | Validación |  |  |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 03.4.2.1 | Crear tipo `Result<T,E>` | [TYPESCRIPT] | Archivo: `src/lib/core/types/result.ts`. **Constantes Maestras v2.0.0 — Result Monad:** `{ ok: true, value: T }` \ | `{ ok: false, error: E }`. **IMPORTANTE:** Las propiedades son `ok` y `value`, NO `success` y `data`. Implementar: `export type Result<T, E = AppError> = { ok: true; value: T } | { ok: false; error: E }; `Funciones helper:` export function ok<T>(value: T): Result<T, never> { return { ok: true, value }; } ``export function err<E>(error: E): Result<never, E> { return { ok: false, error }; } ``export function isOk<T, E>(result: Result<T, E>): result is { ok: true; value: T } { return result.ok; } ``export function isErr<T, E>(result: Result<T, E>): result is { ok: false; error: E } { return !result.ok; } ``export function unwrap<T, E>(result: Result<T, E>): T { if (!result.ok) throw new Error(String(result.error)); return result.value; } ``export function map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> { if (!result.ok) return result; return ok(fn(result.value)); } ``export function flatMap<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> { if (!result.ok) return result; return fn(result.value); }` | Tipo compila sin errores. ok(), err(), isOk(), isErr(), unwrap(), map(), flatMap() funcionan. **Verificar que properties son `ok`/`value`, NO `success`/`data`.** |  |  |  |  |  |  |  |  |  |  |
| 03.4.2.2 | Crear tipo `AppError` base | [TYPESCRIPT] | Archivo: `src/lib/core/types/errors.ts`. Tipo base de error para toda la aplicación: `export interface AppError { code: string; message: string; details?: Record<string, unknown>; }` Constructores helper: `export function appError(code: string, message: string, details?: Record<string, unknown>): AppError { return { code, message, ...(details && { details }) }; }` | AppError compila. Constructor funciona. |  |  |  |  |  |  |  |  |  |  |  |  |
| 03.4.2.3 | Crear tipos de error de dominio: Auth | [TYPESCRIPT] | Archivo: `src/lib/core/types/errors.ts` (mismo archivo). Errores de autenticación: `export type AuthErrorCode = 'UNAUTHORIZED' | 'INVALID_CREDENTIALS' | 'SESSION_EXPIRED' | 'ONBOARDING_INCOMPLETE' | 'ACCOUNT_DELETED'; ``export type AuthError = AppError & { code: AuthErrorCode }; ``export function authError(code: AuthErrorCode, message: string): AuthError { return { code, message }; }` — **Nuevo v2.0.0:** ONBOARDING_INCOMPLETE (oath_taken=false), ACCOUNT_DELETED (deleted_at != null). | Tipos compilan. Codes son string literals. |  |  |  |  |  |  |  |  |
| 03.4.2.4 | Crear tipos de error de dominio: Task | [TYPESCRIPT] | Mismo archivo. `export type TaskErrorCode = 'TASK_NOT_FOUND' | 'TASK_NOT_AVAILABLE' | 'TASK_ALREADY_COMPLETED' | 'AVATAR_HIBERNATED' | 'IDEMPOTENCY_CONFLICT' | 'ALREADY_PROCESSING' | 'DAILY_CAP_REACHED' | 'DATABASE_ERROR'; ``export type TaskError = AppError & { code: TaskErrorCode };` — **Nuevo v2.0.0:** ALREADY_PROCESSING, DAILY_CAP_REACHED (cap es 2,000 base). | Codes correctos. |  |  |  |  |  |
| 03.4.2.5 | Crear tipos de error de dominio: Store | [TYPESCRIPT] | Mismo archivo. `export type StoreErrorCode = 'INSUFFICIENT_FUNDS' | 'LEVEL_TOO_LOW' | 'VECTOR_REQUIREMENT_NOT_MET' | 'STREAK_REQUIREMENT_NOT_MET' | 'PREMIUM_REQUIRED' | 'MAX_PER_USER_REACHED' | 'ITEM_NOT_FOUND' | 'ITEM_LOCKED_BY_DEATH' | 'MAX_EQUIPPED_REACHED'; ``export type StoreError = AppError & { code: StoreErrorCode };` — **Nuevo v2.0.0:** ITEM_LOCKED_BY_DEATH, MAX_EQUIPPED_REACHED (máx 3 equipadas). | Codes correctos. |  |  |  |  |
| 03.4.2.6 | Crear tipos de error de dominio: Vector, Subscription, General | [TYPESCRIPT] | Mismo archivo. `VectorErrorCode = 'INVALID_VECTORS' | 'VECTOR_OUT_OF_RANGE'; ``SubscriptionErrorCode = 'INVALID_PLAN' | 'TRIAL_EXPIRED' | 'PAYMENT_FAILED' | 'ALREADY_SUBSCRIBED'; ``GeneralErrorCode = 'VALIDATION_ERROR' | 'NOT_FOUND' | 'INTERNAL_ERROR' | 'RATE_LIMITED';` Con sus respectivos types e interfaces. | Cada tipo compila. Union type de todos: `export type DomainError = AuthError | TaskError | StoreError | VectorError | SubscriptionError | GeneralError;` |

---

## 03.4.3 — BRANDED TYPES

| ID | Título | Tipo | Detalle | Validación |  |  |
| --- | --- | --- | --- | --- | --- | --- |
| 03.4.3.1 | Crear Branded Types base | [TYPESCRIPT] | Archivo: `src/lib/core/types/branded.ts`. Branded types para prevenir mezcla de IDs: `declare const __brand: unique symbol; type Brand<B> = { [__brand]: B }; export type Branded<T, B> = T & Brand<B>;` **IDs de entidades:** `export type UserId = Branded<string, 'UserId'>;` `export type TaskId = Branded<string, 'TaskId'>;` `export type StoreItemId = Branded<string, 'StoreItemId'>;` `export type InventoryItemId = Branded<string, 'InventoryItemId'>;` `export type NotificationId = Branded<string, 'NotificationId'>;` `export type TransactionId = Branded<string, 'TransactionId'>;` `export type IdempotencyKey = Branded<string, 'IdempotencyKey'>;` `export type QueueItemId = Branded<string, 'QueueItemId'>;` **Constructores con validación:** `export function userId(id: string): UserId { if (!id |  | id.length < 10) throw new Error('Invalid UserId'); return id as UserId; } ``export function taskId(id: string): TaskId { return id as TaskId; } ``export function idempotencyKey(): IdempotencyKey { return `idemp_${[Date.now](http://Date.now)()}_${Math.random().toString(36).substr(2, 9)}` as IdempotencyKey; }` | Branded types previenen mezclar IDs en tiempo de compilación. `userId('abc')` lanza error (< 10 chars). `idempotencyKey()` genera key única con prefijo `idemp_`. |
| 03.4.3.2 | Crear Branded Types numéricos | [TYPESCRIPT] | Mismo archivo. Branded types para valores numéricos con restricciones: `export type BtcAmount = Branded<number, 'BtcAmount'>;` — siempre ≥ 0, entero. `export type VectorValue = Branded<number, 'VectorValue'>;` — 0.00-100.00. `export type EnvValue = Branded<number, 'EnvValue'>;` — 0.00-20.00. `export type HpValue = Branded<number, 'HpValue'>;` — 0-14 (**max expandido 14, NO 13**). `export type OverallScore = Branded<number, 'OverallScore'>;` — 0.00-100.00. Constructores con validación de rango incluidos. | btcAmount(-1) lanza error. vectorValue(101) lanza error. hpValue(15) lanza error (**max 14**). envValue(21) lanza error (**max 20**). |  |  |

---

## 03.4.4 — TIPOS DE DOMINIO: VECTORES

| ID | Título | Tipo | Detalle | Validación |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 03.4.4.1 | Crear tipos de vectores | [TYPESCRIPT] | Archivo: `src/lib/core/types/vectors.ts`. **6 vectores — Constantes Maestras v2.0.0:** `export type VectorName = 'AURA' | 'JAWLINE' | 'WEALTH' | 'PHYSIQUE' | 'SOCIAL' | 'ENV'; ``export type VectorDbColumn = 'aura' | 'jawline' | 'wealth' | 'physique' | 'social' | 'env'; ``export interface VectorState { aura: number; jawline: number; wealth: number; physique: number; social: number; env: number; } ``export interface VectorChanges { aura: number; jawline: number; wealth: number; physique: number; social: number; env: number; } ``export interface VectorRange { min: number; max: number; }` **Rangos v2.0.0:** 5 vectores principales: 0-100. ENV: 0-20. **NOTA:** Versión anterior tenía vectores 0-50 y ENV 1-10. v2.0.0 expande las escalas. | 6 vectores tipados. Rangos correctos: 0-100 (principales), 0-20 (ENV). **NO 0-50 ni 1-10.** |
| 03.4.4.2 | Crear constantes de vectores | [TYPESCRIPT] | Archivo: `src/lib/core/types/vectors.ts` (mismo). `export const VECTOR_NAMES = ['AURA','JAWLINE','WEALTH','PHYSIQUE','SOCIAL','ENV'] as const;` `export const VECTOR_WEIGHTS: Record<VectorName, number> = { AURA: 0.20, JAWLINE: 0.15, WEALTH: 0.20, PHYSIQUE: 0.20, SOCIAL: 0.15, ENV: 0.10 };` `export const ENV_SCALE_FACTOR = 5;` `export const VECTOR_RANGES: Record<VectorName, VectorRange> = { AURA: { min: 0, max: 100 }, JAWLINE: { min: 0, max: 100 }, WEALTH: { min: 0, max: 100 }, PHYSIQUE: { min: 0, max: 100 }, SOCIAL: { min: 0, max: 100 }, ENV: { min: 0, max: 20 } };` `export const VECTOR_DB_MAP: Record<VectorName, VectorDbColumn> = { AURA: 'aura', JAWLINE: 'jawline', WEALTH: 'wealth', PHYSIQUE: 'physique', SOCIAL: 'social', ENV: 'env' };` | Pesos suman 1.0. ENV_SCALE_FACTOR = 5. Rangos correctos v2.0.0. |  |  |  |  |  |  |  |  |  |  |
| 03.4.4.3 | Crear función `calculateOverallScore` (TypeScript mirror) | [TYPESCRIPT] | Mismo archivo. Mirror de la función SQL para uso client-side (UI optimista). `export function calculateOverallScore(vectors: VectorState): number { return Math.round(( vectors.aura * 0.20 + vectors.jawline * 0.15 + vectors.wealth * 0.20 + vectors.physique * 0.20 + vectors.social * 0.15 + (vectors.env * ENV_SCALE_FACTOR) * 0.10 ) * 100) / 100; }` — Fórmula idéntica a `fn_calculate_overall_score` de SQL. | calculateOverallScore({aura:100,jawline:100,wealth:100,physique:100,social:100,env:20}) = 100.00. Con todo en 0 = 0.00. Con todo en 50 y env=10 = 50.00. |  |  |  |  |  |  |  |  |  |  |

---

## 03.4.5 — TIPOS DE DOMINIO: NIVELES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.4.5.1 | Crear tipos y constantes de niveles | [TYPESCRIPT] | Archivo: `src/lib/core/types/levels.ts`. **12 niveles — Constantes Maestras v2.0.0 (NO 13):** `export const LEVEL_NAMES = ['INDIGENTE','REFUGIADO','MANTENIDO','ALUCÍN','PEÓN','HOMBRE COMÚN','INFLUYENTE','PUDIENTE','MILLONARIO','MAGNATE','ÉLITE','SEMI-DIOS'] as const;` `export type LevelName = typeof LEVEL_NAMES[number];` `export interface LevelConfig { index: number; name: LevelName; minScore: number; displayName: string; }` `export const LEVELS: LevelConfig[] = [ { index: 0, name: 'INDIGENTE', minScore: 0, displayName: 'Indigente' }, { index: 1, name: 'REFUGIADO', minScore: 5, displayName: 'Refugiado' }, { index: 2, name: 'MANTENIDO', minScore: 13, displayName: 'Mantenido' }, { index: 3, name: 'ALUCÍN', minScore: 23, displayName: 'Alucín' }, { index: 4, name: 'PEÓN', minScore: 35, displayName: 'Peón' }, { index: 5, name: 'HOMBRE COMÚN', minScore: 45, displayName: 'Hombre Común' }, { index: 6, name: 'INFLUYENTE', minScore: 57, displayName: 'Influyente' }, { index: 7, name: 'PUDIENTE', minScore: 68, displayName: 'Pudiente' }, { index: 8, name: 'MILLONARIO', minScore: 79, displayName: 'Millonario' }, { index: 9, name: 'MAGNATE', minScore: 87, displayName: 'Magnate' }, { index: 10, name: 'ÉLITE', minScore: 94, displayName: 'Élite' }, { index: 11, name: 'SEMI-DIOS', minScore: 98, displayName: 'Semi-Dios' } ];` `export function determineLevel(overallScore: number): LevelConfig { for (let i = LEVELS.length - 1; i >= 0; i--) { if (overallScore >= LEVELS[i].minScore) return LEVELS[i]; } return LEVELS[0]; }` | Array tiene exactamente **12** elementos. Indices 0-11. determineLevel(0)→INDIGENTE. determineLevel(98)→SEMI-DIOS. **NO existe nivel 13 ni LEYENDA.** |
| 03.4.5.2 | Crear constantes de level bonuses | [TYPESCRIPT] | Mismo archivo. `export const LEVEL_HP_BONUS: Record<number, number> = { 3: 1, 6: 1, 9: 1 };` — Niveles index 3 (ALUCÍN), 6 (INFLUYENTE), 9 (MAGNATE) dan +1 HP max. `export const LEVEL_BTC_BONUS: Record<number, number> = { 0: 0, 1: 200, 2: 500, 3: 1000, 4: 1500, 5: 2000, 6: 2500, 7: 3500, 8: 5000, 9: 10000, 10: 20000, 11: 50000 };` — **12 entradas, indices 0-11.** | HP bonus solo en 3 niveles. BTC bonus tiene 12 entradas (NO 13). |

---

## 03.4.6 — TIPOS DE DOMINIO: TAREAS

| ID | Título | Tipo | Detalle | Validación |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 03.4.6.1 | Crear tipos de tareas | [TYPESCRIPT] | Archivo: `src/lib/core/types/tasks.ts`. **17 categorías + 5 arquetipos + 4 status:** `export const TASK_CATEGORIES = ['meditation','thanks','posture','wake_early','facial','voice','cold_shower','skill_learning','focus_work','reading','strength','cardio','hydration','talk_friend','family','kegel','journal'] as const;` `export type TaskCategory = typeof TASK_CATEGORIES[number];` `export const TASK_ARCHETYPES = ['WELLNESS','INTELLECTUAL','SOCIAL','FINANCIAL','LIFESTYLE'] as const;` `export type TaskArchetype = typeof TASK_ARCHETYPES[number];` `export const TASK_STATUSES = ['pending','in_progress','completed','failed'] as const;` `export type TaskStatus = typeof TASK_STATUSES[number];` — **v2.0.0: 4 status (added 'in_progress' y 'failed', removed 'skipped').** `export interface DailyTask { id: TaskId; userId: UserId; category: TaskCategory; archetype: TaskArchetype; title: string; description: string | null; status: TaskStatus; scheduledDate: string; startedAt: string | null; completedAt: string | null; failedAt: string | null; btcEarned: number; vectorChanges: VectorChanges | null; toolType: string | null; toolData: Record<string, unknown> | null; }` | 17 categorías. 5 arquetipos. **4 status (NO 3, NO 'skipped').** Interface completa con campos v2.0.0. |
| 03.4.6.2 | Crear constantes de task config | [TYPESCRIPT] | Mismo archivo. `export interface TaskCategoryConfig { category: TaskCategory; vector: VectorDbColumn; upValue: number; downValue: number; archetype: TaskArchetype; baseBtc: number; repsPerWeek: number; }` `export const TASK_CONFIG: Record<TaskCategory, TaskCategoryConfig> = { meditation: { category: 'meditation', vector: 'aura', upValue: 0.50, downValue: -0.50, archetype: 'WELLNESS', baseBtc: 50, repsPerWeek: 7 }, ...` — Las 17 categorías completas con valores idénticos a fn_get_task_config de SQL. | 17 entradas. Valores match con SQL. Cada categoría tiene vector, up, down, archetype, baseBtc, reps. |  |  |  |  |  |  |  |
| 03.4.6.3 | Crear tipos de dificultad | [TYPESCRIPT] | Mismo archivo. `export const DIFFICULTIES = ['easy','medium','hard','epic'] as const;` `export type Difficulty = typeof DIFFICULTIES[number];` `export const DIFFICULTY_CONFIG: Record<Difficulty, { btcMultiplier: number; vectorMultiplier: number; estimatedMinutes: string; minLevelIndex: number }> = { easy: { btcMultiplier: 1.0, vectorMultiplier: 1.0, estimatedMinutes: '5-15', minLevelIndex: 0 }, medium: { btcMultiplier: 1.5, vectorMultiplier: 1.3, estimatedMinutes: '15-45', minLevelIndex: 0 }, hard: { btcMultiplier: 2.5, vectorMultiplier: 1.8, estimatedMinutes: '45-90', minLevelIndex: 0 }, epic: { btcMultiplier: 4.0, vectorMultiplier: 2.5, estimatedMinutes: '90+', minLevelIndex: 6 } };` — epic disponible desde INFLUYENTE (index 6). | 4 dificultades. epic requiere index≥6. |  |  |  |  |  |  |  |

---

## 03.4.7 — TIPOS DE DOMINIO: ECONOMÍA (BTC & SUSCRIPCIONES)

| ID | Título | Tipo | Detalle | Validación |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 03.4.7.1 | Crear tipos de wallet y BTC | [TYPESCRIPT] | Archivo: `src/lib/core/types/economy.ts`. `export interface Wallet { userId: UserId; btcBalance: number;` — **columna btc_balance, NO balance** `btcEarnedToday: number; totalBtcEarned: number; currentStreak: number; longestStreak: number; currentHp: number; dailyCap: number;` — **default 2,000 NO 3,500** `}` `export const DAILY_CAP_BASE = 2000;` `export const DAILY_CAP_MULTIPLIERS: Record<string, number> = { weekly: 1.1, monthly: 1.2, protocol_100: 1.5 };` `export type TransactionType = 'task_reward' | 'level_up_bonus' | 'purchase' | 'death_penalty' | 'inactivity_penalty'; ``export interface BtcTransaction { id: TransactionId; userId: UserId; type: TransactionType; amount: number; description: string; metadata: Record<string, unknown>; balanceAfter: number; createdAt: string; }` | DAILY_CAP_BASE = 2000. Multipliers para 3 planes. btcBalance como nombre (NO balance). |
| 03.4.7.2 | Crear tipos de suscripción | [TYPESCRIPT] | Mismo archivo. `export const SUBSCRIPTION_PLANS = ['weekly','monthly','protocol_100'] as const;` — **NO 'yearly', NO 'annual'.** `export type SubscriptionPlan = typeof SUBSCRIPTION_PLANS[number];` `export const PLAN_PRICES: Record<SubscriptionPlan, { amount: number; currency: string; display: string }> = { weekly: { amount: 299, currency: 'usd', display: '$2.99/semana' }, monthly: { amount: 999, currency: 'usd', display: '$9.99/mes' }, protocol_100: { amount: 2999, currency: 'usd', display: '$29.99/protocolo' } };` `export const SUBSCRIPTION_STATUSES = ['trial','active','limbo','cancelled'] as const;` `export type SubscriptionStatus = typeof SUBSCRIPTION_STATUSES[number];` `export interface Subscription { userId: UserId; status: SubscriptionStatus; plan: SubscriptionPlan | null; trialEnd: string | null; currentPeriodEnd: string | null; stripeSubscriptionId: string | null; }` | **3 planes (NO 4).** Precios correctos. NO existe 'yearly'. |
| 03.4.7.3 | Crear constantes de multiplicador BTC aditivo | [TYPESCRIPT] | Mismo archivo. **Multiplicador ADITIVO — Constantes Maestras v2.0.0:** `export const BTC_MULTIPLIER_LEVEL_FACTOR = 0.05;` — por level_index `export const STREAK_BONUSES: { minDays: number; bonus: number }[] = [ { minDays: 15, bonus: 1.5 }, { minDays: 8, bonus: 0.5 }, { minDays: 1, bonus: 0.1 }, { minDays: 0, bonus: 0.0 } ];` `export const SUBSCRIPTION_BONUSES: Record<string, number> = { weekly: 0.05, monthly: 0.10, protocol_100: 0.20 };` `export function calculateBtcMultiplier(levelIndex: number, streakDays: number, plan: SubscriptionPlan | null): number { const levelBonus = levelIndex  *BTC_MULTIPLIER_LEVEL_FACTOR; const streakBonus = STREAK_BONUSES.find(s => streakDays >= s.minDays)?.bonus ?? 0; const subBonus = plan ? (SUBSCRIPTION_BONUSES[plan] ?? 0) : 0; return 1.0 + levelBonus + streakBonus + subBonus; }` — Fórmula: 1.0 + (level×0.05) + streak_bonus + sub_bonus. Es SUMA, no multiplicación.** | calculateBtcMultiplier(0, 0, null) = 1.0. calculateBtcMultiplier(4, 10, 'monthly') = 1.0+0.20+0.5+0.10 = 1.80. **Verificar que es ADITIVO.** |  |  |  |
| 03.4.7.4 | Crear constantes de penalización por salud | [TYPESCRIPT] | Mismo archivo. `export const HEALTH_PENALTIES: { maxHp: number; multiplier: number }[] = [ { maxHp: 2, multiplier: 0.50 }, { maxHp: 7, multiplier: 0.90 }, { maxHp: Infinity, multiplier: 1.0 } ];` `export function getHealthPenalty(hp: number): number { for (const p of HEALTH_PENALTIES) { if (hp <= p.maxHp) return p.multiplier; } return 1.0; }` | hp=1→0.50, hp=5→0.90, hp=8→1.0. |  |  |  |  |

---

## 03.4.8 — TIPOS DE DOMINIO: PERSONAJES Y AVATAR

| ID | Título | Tipo | Detalle | Validación |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 03.4.8.1 | Crear tipos de personajes | [TYPESCRIPT] | Archivo: `src/lib/core/types/characters.ts`. **6 personajes — Constantes Maestras v2.0.0:** `export const CHARACTERS = [ { id: 1, key: 'EL_RASTAS', displayName: 'El Rastas' }, { id: 2, key: 'EL_GUARRO', displayName: 'El Guarro' }, { id: 3, key: 'EL_PECAS', displayName: 'El Pecas' }, { id: 4, key: 'EL_GREÑAS', displayName: 'El Greñas' }, { id: 5, key: 'EL_GUERO', displayName: 'El Güero' }, { id: 6, key: 'EL_LIC', displayName: 'El Lic' } ] as const;` `export type CharacterId = 1 | 2 | 3 | 4 | 5 | 6; ``export type CharacterKey = typeof CHARACTERS[number]['key'];` | 6 personajes. IDs 1-6. Nombres correctos. |
| 03.4.8.2 | Crear tipos de muerte y hibernación | [TYPESCRIPT] | Mismo archivo. `export const DEATH_PENALTIES: Record<number, number> = { 1: 0.30, 2: 0.40, 3: 0.50 };` — 1ª=30%, 2ª=40%, 3ª+=50%. `export function getDeathPenalty(deathNumber: number): number { if (deathNumber <= 0) return 0; if (deathNumber === 1) return 0.30; if (deathNumber === 2) return 0.40; return 0.50; }` `export const AURA_PRESERVATION_RATE = 0.30;` — AURA preserva 30% en muerte. `export const HIBERNATION_DURATION_HOURS = 72;` — 3ª+ muerte = 72h hibernación. `export const HP_INITIAL = 5;` `export const HP_MAX_BASE = 10;` `export const HP_MAX_EXPANDED = 14;` — **14, NO 13.** | Penalties correctas. AURA preserva 30%. Hibernación 72h. HP max 14. |  |  |  |  |  |

---

## 03.4.9 — TIPOS DE DOMINIO: HERRAMIENTAS Y TIENDA

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.4.9.1 | Crear tipos de herramientas | [TYPESCRIPT] | Archivo: `src/lib/core/types/tools.ts`. **9 herramientas — Constantes Maestras v2.0.0:** `export const TOOL_KEYS = ['GOLDEN_RAZOR','POWER_SHAKE','CHARM_COLOGNE','BRAIN_SERUM','STREET_CRED_CARD','COLD_SHOWER_TIMER','MUSCLE_BANDS','VISION_BOARD','GRIND_PLAYLIST'] as const;` `export type ToolKey = typeof TOOL_KEYS[number];` `export const MAX_EQUIPPED_TOOLS = 3;` `export interface ToolConfig { key: ToolKey; displayName: string; description: string; priceBtc: number; rarity: ItemRarity; vectorsBoosted: VectorName[]; boostPercentage: number; durationHours: number; levelRequired: number; maxStack: number; categoryAffinity: TaskCategory[]; }` | 9 herramientas. MAX_EQUIPPED = 3. |
| 03.4.9.2 | Crear tipos de rareza de items | [TYPESCRIPT] | Mismo archivo. `export const ITEM_RARITIES = ['common','rare','epic','legendary'] as const;` — **4 niveles. 'uncommon' ELIMINADO en v2.0.0.** `export type ItemRarity = typeof ITEM_RARITIES[number];` | **4 rarities, NO 5.** |

---

## 03.4.10 — TIPOS DE DOMINIO: SALUD, JUDGEMENT, NOTIFICACIONES

| ID | Título | Tipo | Detalle | Validación |  |  |
| --- | --- | --- | --- | --- | --- | --- |
| 03.4.10.1 | Crear tipos de Judgement Night | [TYPESCRIPT] | Archivo: `src/lib/core/types/judgement.ts`. `export const DAY_STATUSES = ['success','failed','death'] as const;` — **3 estados. SIN 'partial'.** `export type DayStatus = typeof DAY_STATUSES[number];` `export const JUDGEMENT_THRESHOLD = 80;` — Porcentaje mínimo para success. **Es BINARIO: ≥80% = success, <80% = failed.** `export interface JudgementResult { date: string; completionPct: number; result: DayStatus; hpChange: number; newHp: number; streak: number; deathTriggered: boolean; newLevel: LevelName; }` | 3 estados. Threshold 80. BINARIO (NO escalones). |  |  |
| 03.4.10.2 | Crear tipos de notificaciones | [TYPESCRIPT] | Archivo: `src/lib/core/types/notifications.ts`. `export const NOTIFICATION_TYPES = ['task_reminder','streak_at_risk','death_warning','level_up','item_unlocked','daily_summary','judgement_success','judgement_failed','avatar_death','avatar_recovered'] as const;` — **10 tipos (NO 7).** `export type NotificationType = typeof NOTIFICATION_TYPES[number];` `export interface AppNotification { id: NotificationId; userId: UserId; type: NotificationType; title: string; body: string; metadata: Record<string, unknown> | null; isRead: boolean; readAt: string | null; createdAt: string; }` | **10 tipos** de notificación. Interface completa. |
| 03.4.10.3 | Crear tipos de image generation | [TYPESCRIPT] | Archivo: `src/lib/core/types/images.ts`. `export const IMAGE_GEN_STATUSES = ['pending','processing','completed','failed','retrying'] as const;` — **5 estados (added 'retrying').** `export type ImageGenStatus = typeof IMAGE_GEN_STATUSES[number];` `export const IMAGE_PROVIDER = 'gemini' as const;` — **Gemini 2.5 Flash ÚNICAMENTE. [fal.ai](http://fal.ai) PROHIBIDO.** `export const IMAGE_STORAGE = 'supabase_storage' as const;` — **Supabase Storage. NO Cloudflare R2.** `export interface ImageQueueItem { id: QueueItemId; userId: UserId; baseAvatarId: CharacterId; vectorsSnapshot: VectorState; equippedItems: string[]; status: ImageGenStatus; provider: typeof IMAGE_PROVIDER; resultUrl: string | null; promptUsed: string | null; attempts: number; maxAttempts: number; }` | 5 status. provider='gemini'. storage='supabase_storage'. |

---

## 03.4.11 — ZOD SCHEMAS DE VALIDACIÓN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.4.11.1 | Crear Zod schema para onboarding | [TYPESCRIPT] | Archivo: `src/lib/core/schemas/onboarding.schema.ts`. `import { z } from 'zod'; export const onboardingSchema = z.object({ baseAvatarId: z.number().int().min(1).max(6),` — **6 personajes** `nickname: z.string().min(2).max(30).regex(/^[a-zA-Z0-9_áéíóúñÁÉÍÓÚÑ]+$/),` `timezone: z.string().min(1),` `locale: z.string().default('es-MX') }); export type OnboardingInput = z.infer<typeof onboardingSchema>;` | Schema valida correctamente. baseAvatarId rechaza 0 y 7. nickname rechaza strings vacíos y caracteres especiales. |
| 03.4.11.2 | Crear Zod schema para complete task | [TYPESCRIPT] | Archivo: `src/lib/core/schemas/task.schema.ts`. `export const completeTaskSchema = z.object({ taskId: z.string().uuid(), idempotencyKey: z.string().startsWith('idemp_'), completionNotes: z.string().max(500).optional(), actualDurationMinutes: z.number().int().min(1).max(480).optional(), toolData: z.record(z.unknown()).optional(), proofUrl: z.string().url().optional() }); export type CompleteTaskInput = z.infer<typeof completeTaskSchema>;` `export const startTaskSchema = z.object({ taskId: z.string().uuid() }); export type StartTaskInput = z.infer<typeof startTaskSchema>;` `export const failTaskSchema = z.object({ taskId: z.string().uuid(), reason: z.string().max(200).optional() }); export type FailTaskInput = z.infer<typeof failTaskSchema>;` | Schemas validan. UUID requerido. idempotencyKey requiere prefijo 'idemp_'. |
| 03.4.11.3 | Crear Zod schema para purchase y equip | [TYPESCRIPT] | Archivo: `src/lib/core/schemas/store.schema.ts`. `export const purchaseItemSchema = z.object({ itemId: z.string(), idempotencyKey: z.string().startsWith('idemp_') }); export type PurchaseItemInput = z.infer<typeof purchaseItemSchema>;` `export const equipItemSchema = z.object({ itemId: z.string() }); export type EquipItemInput = z.infer<typeof equipItemSchema>;` `export const unequipItemSchema = z.object({ itemId: z.string() }); export type UnequipItemInput = z.infer<typeof unequipItemSchema>;` | Schemas validan. |
| 03.4.11.4 | Crear Zod schema para profile update | [TYPESCRIPT] | Archivo: `src/lib/core/schemas/profile.schema.ts`. `export const updateProfileSchema = z.object({ nickname: z.string().min(2).max(30).optional(), timezone: z.string().optional(), locale: z.string().optional() }); export type UpdateProfileInput = z.infer<typeof updateProfileSchema>;` — **NO permite cambiar base_avatar_id, email, phone_encrypted, oath_taken, deleted_at desde client.** | Schema no incluye campos protegidos. |
| 03.4.11.5 | Crear Zod schema para Stripe webhook | [TYPESCRIPT] | Archivo: `src/lib/core/schemas/stripe.schema.ts`. `export const stripeWebhookSchema = z.object({ type: z.string(), data: z.object({ object: z.record(z.unknown()) }) }); export const subscriptionChangeSchema = z.object({ plan: z.enum(['weekly','monthly','protocol_100']),` — **3 planes, NO 'yearly'** `status: z.enum(['trial','active','limbo','cancelled']), stripeSubscriptionId: z.string(), currentPeriodStart: z.string().datetime(), currentPeriodEnd: z.string().datetime() }); export type SubscriptionChangeInput = z.infer<typeof subscriptionChangeSchema>;` | plan enum rechaza 'yearly'. Solo acepta 3 planes válidos. |

---
# ══════════════════════════════════════════════════════════════

# SUBCAJA 03.5 — SERVER ACTIONS (Next.js 15)

# Auth Middleware · Onboarding · Daily Tasks · Dashboard · Store · Tools · Profile · Notifications · Avatar/Image · Payments

# 58 TAREAS (vs 38 original)

# ══════════════════════════════════════════════════════════════

---

## 03.5.1 — AUTH MIDDLEWARE & PROTECCIÓN DE RUTAS

| ID | Título | Tipo | Detalle | Validación |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 03.5.1.1 | Crear middleware de autenticación Next.js 15 | [TYPESCRIPT] | Archivo: `src/middleware.ts`. Usa `createMiddlewareSupabaseClient` para refrescar sesión en cada request. Lógica: 1) Crear client con request. 2) `await supabase.auth.getUser()`. 3) Si no autenticado y ruta protegida → redirect a `/auth/login`. 4) Si autenticado y ruta `/auth/*` → redirect a `/dashboard`. 5) Retornar response con cookies actualizadas. Config matcher: `['/((?!_next/static | _next/image | favicon.ico | api/webhooks).*)']` — Excluir `/api/webhooks/*` porque Stripe webhooks no llevan sesión de usuario. | Rutas protegidas redirigen a login. Rutas auth redirigen a dashboard si autenticado. Webhooks NO pasan por middleware de auth. Sesión se refresca correctamente. |
| 03.5.1.2 | Crear helper `withAuth` para Server Actions | [TYPESCRIPT] | Archivo: `src/lib/server/auth/with-auth.ts`. HOF (Higher-Order Function) que wrappea Server Actions con autenticación: `export function withAuth<TInput, TOutput>(action: (userId: UserId, input: TInput) => Promise<Result<TOutput, DomainError>>): (input: TInput) => Promise<Result<TOutput, DomainError>> { return async (input: TInput) => { const supabase = await createServerSupabaseClient(); const { data: { user }, error } = await supabase.auth.getUser(); if (error |  | !user) return err(authError('UNAUTHORIZED', 'No authenticated session')); return action(userId([user.id](http://user.id)), input); }; } `— **IMPORTANTE:** Usar` getUser() `(valida con Supabase Auth server), NO` getSession()` (solo lee cookie, no valida). | withAuth rechaza requests sin sesión con `{ ok: false, error: { code: 'UNAUTHORIZED' } }`. Usa getUser() NO getSession(). |  |
| 03.5.1.3 | Crear helper `withAuthAndValidation` | [TYPESCRIPT] | Mismo archivo. Combina auth + validación Zod: `export function withAuthAndValidation<TInput, TOutput>(schema: z.ZodSchema<TInput>, action: (userId: UserId, input: TInput) => Promise<Result<TOutput, DomainError>>): (rawInput: unknown) => Promise<Result<TOutput, DomainError>> { return async (rawInput: unknown) => { const parsed = schema.safeParse(rawInput); if (!parsed.success) return err(appError('VALIDATION_ERROR', parsed.error.message)); const supabase = await createServerSupabaseClient(); const { data: { user }, error } = await supabase.auth.getUser(); if (error |  | !user) return err(authError('UNAUTHORIZED', 'No authenticated session')); return action(userId([user.id](http://user.id)), [parsed.data](http://parsed.data)); }; }` | Valida input con Zod antes de auth. Input inválido → `{ ok: false, error: { code: 'VALIDATION_ERROR' } }`. |  |
| 03.5.1.4 | Crear helper `withServiceRole` para cron/webhooks | [TYPESCRIPT] | Mismo archivo. Para acciones que NO requieren sesión de usuario (webhooks Stripe, cron jobs Inngest): `export function withServiceRole<TInput, TOutput>(action: (adminClient: SupabaseClient, input: TInput) => Promise<Result<TOutput, DomainError>>): (input: TInput) => Promise<Result<TOutput, DomainError>> { return async (input: TInput) => { const adminClient = createAdminSupabaseClient(); return action(adminClient, input); }; }` — Usa service_role key. **Solo accesible desde API routes internas y cron jobs.** | Client usa service_role. Bypasea RLS. |  |  |  |
| 03.5.1.5 | Crear verificación de onboarding completado | [TYPESCRIPT] | Archivo: `src/lib/server/auth/check-onboarding.ts`. Middleware helper que verifica `oath_taken = true` en profiles. Si false → retorna `err(authError('ONBOARDING_INCOMPLETE', '...'))`. Se usa dentro de Server Actions que requieren que el usuario haya completado onboarding (todas excepto la propia acción de onboarding). | Usuario sin oath_taken → ONBOARDING_INCOMPLETE. Usuario con oath_taken → continúa normalmente. |  |  |  |
| 03.5.1.6 | Crear verificación de hibernación | [TYPESCRIPT] | Archivo: `src/lib/server/auth/check-hibernation.ts`. Verifica si el usuario está en hibernación invocando `fn_check_hibernation_status`. Si en hibernación → retorna `err(appError('AVATAR_HIBERNATED', '...'))` con `hours_remaining` en details. Se usa en Server Actions de tareas y tienda. | Hibernado → error con hours_remaining. No hibernado → continúa. |  |  |  |

---

## 03.5.2 — SERVER ACTIONS: ONBOARDING

| ID | Título | Tipo | Detalle | Validación |  |  |
| --- | --- | --- | --- | --- | --- | --- |
| 03.5.2.1 | Crear action `completeOnboarding` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/onboarding.ts`. `'use server';` Wrappear con `withAuthAndValidation(onboardingSchema, ...)`. Lógica: 1) Verificar que onboarding NO está ya completado (profiles.oath_taken !== true). Si ya completado → `err('ALREADY_ONBOARDED')`. 2) Llamar RPC `fn_complete_onboarding(p_user_id, p_base_avatar_id, p_nickname, p_timezone, p_locale)`. **base_avatar_id 1-6:** EL_RASTAS, EL_GUARRO, EL_PECAS, EL_GREÑAS, EL_GUERO, EL_LIC. 3) Parsear respuesta JSONB → Result Monad. Si `ok: true` → retornar value. Si `ok: false` → retornar error. 4) `revalidatePath('/dashboard')`. Retorna `Result<{ profileUpdated: true; tasksGenerated: number; imageQueued: true }, DomainError>`. | Onboarding completa exitosamente. base_avatar_id 1-6 aceptado. Nickname guardado. Ya completado → error. Result usa `ok/value`. |  |  |
| 03.5.2.2 | Crear action `getOnboardingStatus` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Query simple: `SELECT oath_taken, onboarding_completed_at, base_avatar_id FROM profiles WHERE id = p_user_id`. Retorna `Result<{ isComplete: boolean; baseAvatarId: number | null; completedAt: string | null }, DomainError>`. | Retorna estado correcto de onboarding. |

---

## 03.5.3 — SERVER ACTIONS: DAILY TASKS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.3.1 | Crear action `getDailyTasks` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/tasks.ts`. `'use server';` Wrappear con `withAuth`. Verificar onboarding + hibernación. Query: `SELECT * FROM daily_tasks WHERE user_id = $1 AND scheduled_date = CURRENT_DATE ORDER BY created_at`. Mapear a tipos TypeScript con **4 status (pending, in_progress, completed, failed — NO skipped)**. Incluir: category (17 categorías), archetype (5), btc_earned, vector_changes JSONB, tool_type, started_at, completed_at, failed_at. Retorna `Result<{ tasks: DailyTask[]; summary: { total: number; completed: number; inProgress: number; pending: number; failed: number; completionPct: number } }, DomainError>`. | Retorna tareas del día actual. 4 status. Summary con porcentajes correctos. |
| 03.5.3.2 | Crear action `startTask` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuthAndValidation(startTaskSchema, ...)`. Verificar onboarding + hibernación. Llamar RPC `fn_start_task(p_user_id, p_task_id)`. Parsear Result Monad. `revalidatePath('/dashboard')`. Retorna `Result<{ taskId: string; startedAt: string }, DomainError>`. | Tarea cambia a in_progress. Segunda simultánea → error. |
| 03.5.3.3 | Crear action `completeTask` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuthAndValidation(completeTaskSchema, ...)`. Verificar onboarding + hibernación. **Lógica:** 1) Generar `idempotencyKey()` si no proporcionado. 2) Llamar RPC `fn_complete_task_transaction(p_user_id, p_task_id, p_idempotency_key, p_completion_notes, p_actual_duration_minutes, p_tool_data)`. 3) Parsear Result Monad JSONB. 4) Si `ok: true` → extraer: btc_earned, multiplier_applied (**multiplicador ADITIVO**), cap_limited (cap **2,000** base), vectors_updated, new_overall, level_changed, current_level (**12 niveles**). 5) `revalidatePath('/dashboard')`. 6) Opcionalmente: si la tarea tiene categoría que requiere proof y proof_url fue proporcionado, subir proof a **Supabase Storage** (NO R2). Retorna `Result<CompleteTaskResult, DomainError>`. | Tarea completada. BTC reward calculado con multiplicador aditivo. Daily cap 2,000 respetado. Idempotencia funciona. Result usa ok/value. |
| 03.5.3.4 | Crear action `failTask` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuthAndValidation(failTaskSchema, ...)`. Verificar onboarding. Llamar RPC `fn_fail_task(p_user_id, p_task_id, p_reason)`. Parsear Result. `revalidatePath('/dashboard')`. Retorna `Result<{ taskId: string; newCompletionPct: number }, DomainError>`. | Tarea marcada failed. Completion % recalculado. |
| 03.5.3.5 | Crear action `generateDailyTasks` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Verificar onboarding + hibernación. Llamar RPC `fn_generate_daily_tasks(p_user_id, CURRENT_DATE)`. Si ya existen tareas para hoy → `err('TASKS_ALREADY_GENERATED')`. **Número de tareas:** 7-10 según nivel (INDIGENTE-MANTENIDO→7, ALUCÍN-HOMBRE COMÚN→8, INFLUYENTE-MILLONARIO→9, MAGNATE-SEMI-DIOS→10). `revalidatePath('/dashboard')`. Retorna `Result<{ tasksGenerated: number; date: string }, DomainError>`. | Tareas generadas según nivel. Duplicados rechazados. |
| 03.5.3.6 | Crear action `enrichTaskWithAI` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Lógica: 1) Llamar RPC `fn_enrich_task_with_ai_prompt(p_task_id)` para obtener prompt payload. 2) Enviar prompt a **Gemini 2.5 Flash** vía API (Google AI SDK). [**fal.ai](http://fal.ai) PROHIBIDO.** 3) Recibir descripción personalizada. 4) UPDATE daily_tasks SET description = ai_response WHERE id = p_task_id (vía admin client). 5) Retornar descripción. **IMPORTANTE:** Esta acción puede ser llamada en paralelo para múltiples tareas tras generación diaria. Rate limiting: máx 10 calls/minuto por usuario vía **Upstash Redis** (rate limiter). | Descripción generada por Gemini. Actualizada en DB. Rate limited vía Upstash Redis. NO usa [fal.ai](http://fal.ai). |

---

## 03.5.4 — SERVER ACTIONS: DASHBOARD & ESTADO

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.4.1 | Crear action `getUserFullState` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/dashboard.ts`. `'use server';` Wrappear con `withAuth`. Llamar RPC `fn_get_user_full_state(p_user_id)`. Parsear JSONB con 7 secciones: profile (incluyendo **nickname**, oath_taken, locale, deleted_at), vectors (6 vectores escala **0-100/0-20**), wallet (**btc_balance** NO balance, daily_cap default **2,000**), subscription (plan **weekly/monthly/protocol_100**), today_tasks, equipped_items, unread_notifications_count. Calcular overall_score client-side con `calculateOverallScore()` como verificación. Determinar nivel con `determineLevel()` (**12 niveles**). Retorna `Result<UserFullState, DomainError>`. | JSONB completo. 6 vectores. btc_balance. 12 niveles. Planes correctos. |
| 03.5.4.2 | Crear action `getUserHistory` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Llamar RPC `fn_get_user_history(p_user_id, p_days)`. Retorna últimos N daily_logs con vectores snapshot, level_history, btc_transactions summary. Para gráficas de progreso en UI. Retorna `Result<UserHistory, DomainError>`. | Historial de 30 días por default. Snapshots con 6 vectores. |
| 03.5.4.3 | Crear action `getLeaderboard` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Query con admin client (bypasea RLS para leer otros usuarios): `SELECT p.nickname, p.base_avatar_id, overall_score, fn_determine_level(overall_score) as level FROM profiles p WHERE p.deleted_at IS NULL AND p.oath_taken = true ORDER BY overall_score DESC LIMIT 20`. **Solo expone:** nickname, base_avatar_id, overall_score, level. **NO expone:** email, phone, vectores individuales, BTC, etc. Retorna `Result<LeaderboardEntry[], DomainError>`. | Top 20 usuarios. Solo datos públicos. No expone info sensible. |

---

## 03.5.5 — SERVER ACTIONS: TIENDA & INVENTARIO

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.5.1 | Crear action `getStoreCatalog` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/store.ts`. `'use server';` Wrappear con `withAuth`. Verificar onboarding. Llamar RPC `fn_get_store_catalog(p_user_id)`. Retorna catálogo personalizado con 9 herramientas, cada una con estado (available, owned, locked_level, locked_funds). **Rarities: 4 niveles (common, rare, epic, legendary — SIN uncommon).** Retorna `Result<StoreItem[], DomainError>`. | 9 herramientas. 4 rarities. Estado personalizado. |
| 03.5.5.2 | Crear action `purchaseItem` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuthAndValidation(purchaseItemSchema, ...)`. Verificar onboarding + hibernación. Llamar RPC `fn_purchase_item(p_user_id, p_item_id, p_idempotency_key)`. Parsear Result Monad. `revalidatePath('/store')`. `revalidatePath('/dashboard')`. Retorna `Result<{ itemId: string; newBalance: number; quantity: number }, DomainError>`. | Compra exitosa. Balance actualizado. Idempotencia funciona. Fondos insuficientes → ok:false. |
| 03.5.5.3 | Crear action `equipItem` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuthAndValidation(equipItemSchema, ...)`. Verificar onboarding. Llamar RPC `fn_equip_item(p_user_id, p_item_id)`. **Máx 3 herramientas equipadas simultáneamente.** Recalcula ENV internamente. `revalidatePath('/dashboard')`. Retorna `Result<{ itemId: string; equipped: true; totalEquipped: number }, DomainError>`. | Item equipado. ENV recalculado. Límite 3 respetado. |
| 03.5.5.4 | Crear action `unequipItem` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuthAndValidation(unequipItemSchema, ...)`. Llamar RPC `fn_unequip_item(p_user_id, p_item_id)`. Recalcula ENV. `revalidatePath('/dashboard')`. Retorna `Result<{ itemId: string; equipped: false; totalEquipped: number }, DomainError>`. | Item desequipado. ENV recalculado. |
| 03.5.5.5 | Crear action `unlockDeathItem` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Verificar que usuario tiene muerte recuperada. Llamar RPC `fn_unlock_death_items(p_user_id, p_inventory_id)`. Costo = 25% del precio original del item. `revalidatePath('/inventory')`. Retorna `Result<{ unlocked: true; cost: number; newBalance: number }, DomainError>`. | Item desbloqueado. BTC deducidos (25% precio). |
| 03.5.5.6 | Crear action `getInventory` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Query: `SELECT i.*, si.name, si.rarity, si.slot, si.ia_token FROM inventory i JOIN store_items si ON si.id = i.item_id WHERE i.user_id = $1 ORDER BY i.purchased_at DESC`. Incluir flag `locked_by_death` para UI. Retorna `Result<InventoryItem[], DomainError>`. | Inventario completo con detalles de items. |

---

## 03.5.6 — SERVER ACTIONS: HERRAMIENTAS (9 Tools)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.6.1 | Crear action `getToolProgress` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/tools.ts`. `'use server';` Wrappear con `withAuth`. Query: `SELECT * FROM tool_progress WHERE user_id = $1`. Retorna progreso de las **9 herramientas**: GOLDEN_RAZOR, POWER_SHAKE, CHARM_COLOGNE, BRAIN_SERUM, STREET_CRED_CARD, COLD_SHOWER_TIMER, MUSCLE_BANDS, VISION_BOARD, GRIND_PLAYLIST. Cada una con total_sessions, total_duration, current_streak, best_streak, last_session_at, tool_specific_data. Retorna `Result<ToolProgress[], DomainError>`. | 9 herramientas. Progreso completo por herramienta. |
| 03.5.6.2 | Crear action `recordToolSession` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Parámetros: `toolType, durationMinutes, sessionData`. Lógica: 1) Verificar onboarding. 2) UPDATE tool_progress SET total_sessions+1, total_duration_minutes+duration, last_session_at=NOW(), current_streak (si sesión consecutiva día anterior), tool_specific_data (merge con sessionData). 3) Si hay tarea daily_task asociada a este tool_type para hoy con status pending/in_progress → marcar como in_progress o completar automáticamente según duración. Retorna `Result<{ updated: true; newTotalSessions: number }, DomainError>`. | Sesión registrada. Tarea asociada actualizada si aplica. |

---

## 03.5.7 — SERVER ACTIONS: PERFIL

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.7.1 | Crear action `getProfile` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/profile.ts`. `'use server';` Wrappear con `withAuth`. Query: `SELECT id, email, nickname, base_avatar_id, oath_taken, timezone, locale, onboarding_completed_at, created_at FROM profiles WHERE id = $1`. **NO retornar phone_encrypted directamente** — solo indicar si existe (has_phone: boolean). Retorna `Result<UserProfile, DomainError>`. | Perfil retornado. phone_encrypted NO expuesto. nickname incluido. |
| 03.5.7.2 | Crear action `updateProfile` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuthAndValidation(updateProfileSchema, ...)`. Llamar RPC `fn_update_profile(p_user_id, p_nickname, p_timezone, p_locale)`. **Restricción timezone:** Si se cambia timezone, fn_update_profile verifica que timezone_changed_at tenga ≥24h de diferencia (previene abuse para duplicar recompensas diarias). Si <24h → `err('TIMEZONE_COOLDOWN')`. `revalidatePath('/profile')`. Retorna `Result<{ updatedFields: string[] }, DomainError>`. | Perfil actualizado. Timezone cooldown 24h respetado. |
| 03.5.7.3 | Crear action `deleteAccount` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Llamar RPC `fn_soft_delete_account(p_user_id)`. Soft delete: profiles.deleted_at = NOW(). No elimina datos reales. Redirigir a `/auth/goodbye`. Retorna `Result<{ deletedAt: string }, DomainError>`. | Cuenta soft-deleted. Datos preservados. |

---

## 03.5.8 — SERVER ACTIONS: NOTIFICACIONES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.8.1 | Crear action `getNotifications` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/notifications.ts`. `'use server';` Wrappear con `withAuth`. Query: `SELECT * FROM notifications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 50`. **10 tipos de notificación** (v2.0.0). Incluir conteo de no leídas. Retorna `Result<{ notifications: AppNotification[]; unreadCount: number }, DomainError>`. | Últimas 50 notificaciones. 10 tipos. Conteo de no leídas. |
| 03.5.8.2 | Crear action `markNotificationsRead` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Llamar RPC `fn_mark_notifications_read(p_user_id, p_notification_ids)`. Si p_notification_ids es null → marcar TODAS como leídas. `revalidatePath('/notifications')`. Retorna `Result<{ markedCount: number }, DomainError>`. | Notificaciones marcadas. |
| 03.5.8.3 | Crear action `getUnreadNotificationCount` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Query ligera: `SELECT COUNT(*) FROM notifications WHERE user_id = $1 AND is_read = false`. Para badge en UI sin cargar todas las notificaciones. Retorna `Result<{ count: number }, DomainError>`. | Conteo correcto. Query optimizada (usa índice parcial idx_notifications_unread). |

---

## 03.5.9 — SERVER ACTIONS: AVATAR & GENERACIÓN DE IMAGEN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.9.1 | Crear action `getAvatarImage` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/avatar.ts`. `'use server';` Wrappear con `withAuth`. Query: `SELECT result_url, status FROM image_generation_queue WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1`. Si status='completed' → retornar result_url (URL de **Supabase Storage**, NO R2). Si status IN ('pending','processing','retrying') → retornar `{ status: 'generating' }`. Si status='failed' → retornar `{ status: 'failed' }`. **ImageGenStatus: 5 estados (pending, processing, completed, failed, retrying).** Retorna `Result<AvatarImageResult, DomainError>`. | Imagen más reciente retornada. URL apunta a Supabase Storage. 5 status reconocidos. |
| 03.5.9.2 | Crear action `requestAvatarRegeneration` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Verificar onboarding. Lógica: 1) Verificar rate limit vía **Upstash Redis**: máx 3 regeneraciones por día por usuario. 2) Verificar que no hay imagen in-flight (pending/processing/retrying). 3) Llamar RPC `fn_queue_image_generation(p_user_id, 'manual_regen', priority=8)`. provider='**gemini**'. 4) Retorna `Result<{ queueId: string; position: number }, DomainError>`. | Imagen encolada. Rate limit 3/día vía Upstash Redis. provider=gemini. No duplicados in-flight. |
| 03.5.9.3 | Crear action `getAvatarHistory` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Query: `SELECT id, vectors_snapshot, status, result_url, created_at FROM image_generation_queue WHERE user_id = $1 AND status = 'completed' ORDER BY created_at DESC LIMIT 10`. Retorna galería de últimas 10 imágenes de avatar completadas. Retorna `Result<AvatarHistoryEntry[], DomainError>`. | Últimas 10 imágenes. Solo status='completed'. URLs de Supabase Storage. |

---

## 03.5.10 — SERVER ACTIONS: PAGOS & SUSCRIPCIÓN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.10.1 | Crear action `getSubscriptionStatus` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/payments.ts`. `'use server';` Wrappear con `withAuth`. Query: `SELECT * FROM subscriptions WHERE user_id = $1`. Calcular: days_remaining (trial o período), is_trial, can_upgrade. Retorna `Result<SubscriptionInfo, DomainError>`. **Planes: weekly ($2.99), monthly ($9.99), protocol_100 ($29.99). NO yearly.** | Status correcto. Planes v2.0.0. |
| 03.5.10.2 | Crear action `createCheckoutSession` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Parámetro: `plan: SubscriptionPlan`. Validar que plan ∈ ['weekly', 'monthly', 'protocol_100']. **Rechazar 'yearly'.** Lógica: 1) Verificar que usuario no tiene suscripción activa del mismo plan. 2) Crear Stripe Checkout Session con `stripe.checkout.sessions.create({ mode: 'subscription', line_items: [{ price: STRIPE_PRICE_IDS[plan], quantity: 1 }], customer_email: user.email, metadata: { userId: user.id, plan }, success_url: '...', cancel_url: '...' })`. 3) Retornar checkout URL. Retorna `Result<{ checkoutUrl: string }, DomainError>`. | Checkout session creada. Plan válido (3 opciones). 'yearly' rechazado. URL retornada. |
| 03.5.10.3 | Crear action `createPortalSession` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Para gestionar suscripción existente (cancelar, cambiar payment method). Lógica: 1) Obtener stripe_customer_id de subscriptions. 2) `stripe.billingPortal.sessions.create({ customer: stripeCustomerId, return_url: '...' })`. Retorna `Result<{ portalUrl: string }, DomainError>`. | Portal session creada. URL retornada. |
| 03.5.10.4 | Crear action `getPaymentHistory` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withAuth`. Query: `SELECT * FROM payments WHERE user_id = $1 ORDER BY created_at DESC LIMIT 20`. Retorna historial de pagos con amount, currency, status, plan. Retorna `Result<PaymentRecord[], DomainError>`. | Últimos 20 pagos. Planes correctos. |

---

## 03.5.11 — SERVER ACTIONS: JUDGEMENT NIGHT (Invocadas por Cron)

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.11.1 | Crear action `triggerJudgementNight` | [TYPESCRIPT] | Archivo: `src/lib/server/actions/judgement.ts`. `'use server';` Wrappear con `withServiceRole`. **Invocada por Inngest cron job.** Lógica: 1) Llamar RPC `fn_process_judgement_batch(CURRENT_DATE)` con admin client. 2) La función SQL internamente filtra por timezone del usuario. 3) Retorna summary: total_users, successes, failures, deaths, errors. **Judgement es BINARIO: ≥80% success, <80% failed. NO escalones intermedios.** 4) Log resultado en activity_logs o sistema de monitoring. Retorna `Result<JudgementBatchResult, DomainError>`. | Batch ejecutado. Solo usuarios cuyo día terminó. Resultados binarios. |
| 03.5.11.2 | Crear action `triggerDailyReset` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withServiceRole`. **Invocada por Inngest cron job cada hora.** Lógica: 1) Llamar RPC `fn_reset_daily_btc_counter()` — resetea btc_earned_today para usuarios cuyo día cambió según timezone. 2) Llamar RPC `fn_generate_daily_tasks` para usuarios que aún no tienen tareas del nuevo día (si configurado para auto-gen). 3) Aplicar vector decay vía `fn_apply_daily_vector_decay` para usuarios del día anterior sin judgement. Retorna `Result<DailyResetResult, DomainError>`. | BTC counters reseteados por timezone. Tareas generadas. Decay aplicado. |
| 03.5.11.3 | Crear action `triggerInactivityCheck` | [TYPESCRIPT] | Mismo archivo. `'use server';` Wrappear con `withServiceRole`. **Invocada por Inngest cron job diario.** Lógica: 1) Buscar usuarios sin daily_log en los últimos 3+ días. 2) Para cada uno: `fn_apply_inactivity_penalty(p_user_id, p_inactive_days)`. 3) Enviar notificaciones de warning (4-7 días) o penalty (8+ días). Retorna `Result<{ usersChecked: number; penaltiesApplied: number }, DomainError>`. | Usuarios inactivos detectados. Penalizaciones aplicadas. Notificaciones enviadas. |

---

## 03.5.12 — SERVER ACTIONS: WEBHOOKS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.5.12.1 | Crear handler de webhook Stripe | [TYPESCRIPT] | Archivo: `src/app/api/webhooks/stripe/route.ts`. **Route Handler (NO Server Action)** — Next.js 15 App Router. Lógica: 1) Verificar firma del webhook con `stripe.webhooks.constructEvent(body, sig, STRIPE_WEBHOOK_SECRET)`. 2) Switch por event.type: **'checkout.session.completed'** → Llamar `fn_process_subscription_change` con plan extraído de metadata. Planes: **weekly, monthly, protocol_100.** **'invoice.payment_succeeded'** → Renovación exitosa. UPDATE subscription period dates. **'invoice.payment_failed'** → Llamar `fn_handle_payment_failed`. Status → 'limbo'. **'customer.subscription.deleted'** → UPDATE subscription status='cancelled'. Recalcular daily_cap y ENV. 3) Responder 200 OK. 4) **NO pasa por middleware de auth** (excluido en matcher). | Webhook procesa eventos correctamente. Firma validada. Planes correctos (NO yearly). Status actualizados. 200 OK retornado. |
| 03.5.12.2 | Crear handler de webhook Inngest | [TYPESCRIPT] | Archivo: `src/app/api/inngest/route.ts`. Expone el endpoint de Inngest para recibir y despachar funciones. `import { serve } from 'inngest/next'; import { inngest } from '@/lib/server/inngest/client'; import { functions } from '@/lib/server/inngest/functions';` `export const { GET, POST, PUT } = serve({ client: inngest, functions });` — Las funciones de Inngest incluyen: dailyJudgement, dailyReset, inactivityCheck, imageGeneration, trialExpiration, cleanup. | Endpoint accesible. Funciones registradas. GET retorna dashboard de Inngest. |

---

## 03.5.13 — SERVER ACTIONS: UPSTASH REDIS (RATE LIMITING & CACHE)

| ID | Título | Tipo | Detalle | Validación |  |  |
| --- | --- | --- | --- | --- | --- | --- |
| 03.5.13.1 | Crear cliente Upstash Redis | [TYPESCRIPT] | Archivo: `src/lib/server/redis/client.ts`. `import { Redis } from '@upstash/redis'; export const redis = new Redis({ url: process.env.UPSTASH_REDIS_REST_URL!, token: process.env.UPSTASH_REDIS_REST_TOKEN! });` — **EXCEPCIÓN: Upstash Redis SE MANTIENE a pesar de que la documentación v2.0.0 lo descarta. Decisión explícita del usuario.** | Client se conecta correctamente. ping() retorna 'PONG'. |  |  |
| 03.5.13.2 | Crear rate limiter con Upstash | [TYPESCRIPT] | Archivo: `src/lib/server/redis/rate-limiter.ts`. `import { Ratelimit } from '@upstash/ratelimit'; import { redis } from './client';` Crear limiters por acción: `export const taskCompletionLimiter = new Ratelimit({ redis, limiter: Ratelimit.slidingWindow(10, '1 m'), prefix: 'rl:task' });` — Máx 10 task completions por minuto. `export const imageRegenLimiter = new Ratelimit({ redis, limiter: Ratelimit.fixedWindow(3, '24 h'), prefix: 'rl:img' });` — Máx 3 regeneraciones por día. `export const apiGeneralLimiter = new Ratelimit({ redis, limiter: Ratelimit.slidingWindow(60, '1 m'), prefix: 'rl:api' });` — Máx 60 requests por minuto general. Helper: `export async function checkRateLimit(limiter: Ratelimit, identifier: string): Promise<Result<true, DomainError>>`. | Rate limiters funcionan. Requests excesivos rechazados con `{ ok: false, error: { code: 'RATE_LIMITED' } }`. |  |  |
| 03.5.13.3 | Crear cache helpers con Upstash | [TYPESCRIPT] | Archivo: `src/lib/server/redis/cache.ts`. Cache para datos frecuentemente accedidos: `export async function getCachedUserState(userId: string): Promise<UserFullState | null> `— TTL 30 segundos.` export async function invalidateUserCache(userId: string): Promise<void> `— Llamar después de cada mutación (complete task, judgement, purchase, etc.).` export async function getCachedStoreCatalog(): Promise<StoreItem[] | null> `— TTL 5 minutos (catálogo cambia poco). Todas las funciones usan` redis.get/set` con serialización JSON. | Cache funciona. TTL correcto. Invalidación después de mutaciones. |
| 03.5.13.4 | Crear BullMQ queue para image generation | [TYPESCRIPT] | Archivo: `src/lib/server/redis/image-queue.ts`. **EXCEPCIÓN: BullMQ SE MANTIENE.** `import { Queue, Worker } from 'bullmq'; import IORedis from 'ioredis';` `const connection = new IORedis(process.env.UPSTASH_REDIS_URL!);` `export const imageQueue = new Queue('image-generation', { connection });` Worker procesa jobs: 1) Obtener prompt de `fn_build_image_prompt`. 2) Enviar a **Gemini 2.5 Flash** API. 3) Recibir imagen generada. 4) Subir a **Supabase Storage** (NO R2). 5) UPDATE image_generation_queue SET status='completed', result_url. 6) Si error: retry con backoff exponencial, max 3 attempts. Si falla 3 veces → status='failed'. **NOTA:** BullMQ complementa a Inngest — BullMQ maneja la cola de imágenes con retry/backoff, Inngest maneja los cron jobs scheduled. | Queue funciona. Worker procesa jobs. Retry con backoff. Imágenes subidas a Supabase Storage. provider=gemini. |  |  |

---
# ══════════════════════════════════════════════════════════════

# SUBCAJA 03.6 — MIGRATIONS & SEED DATA

# Archivos de Migración · Seed Data · Scripts de Verificación · Configuración Supabase

# 34 TAREAS (vs 20 original)

# ══════════════════════════════════════════════════════════════

---

## 03.6.1 — ESTRUCTURA DE ARCHIVOS DE MIGRACIÓN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.1.1 | Crear directorio de migraciones | [CONFIG] | Estructura: `supabase/migrations/` con archivos nombrados secuencialmente con timestamp: `20260101000001_extensions.sql`, `20260101000002_enums.sql`, `20260101000003_tables.sql`, `20260101000004_indexes.sql`, `20260101000005_triggers.sql`, `20260101000006_functions_auxiliary.sql`, `20260101000007_functions_core.sql`, `20260101000008_functions_judgement.sql`, `20260101000009_functions_store.sql`, `20260101000010_functions_misc.sql`, `20260101000011_rls_enable.sql`, `20260101000012_rls_policies.sql`, `20260101000013_seed_store_items.sql`. **IMPORTANTE:** Cada archivo debe ser idempotente (usar `IF NOT EXISTS`, `CREATE OR REPLACE` donde aplique). Orden de ejecución es crítico — las dependencias se resuelven por orden de timestamp. | Directorio existe. 13 archivos de migración con timestamps secuenciales. `supabase db reset` ejecuta sin errores en orden. |
| 03.6.1.2 | Crear archivo `supabase/config.toml` actualizado | [CONFIG] | Archivo de configuración de Supabase CLI. Secciones clave: `[project]` con project_id y api url. `[db]` con port=54322. `[auth]` con site_url, redirect_urls, **email templates nativas de Supabase Auth** (NO Resend). `[auth.email]` con enable_signup=true, double_confirm_changes=true, enable_confirmations=true. **NO configurar Resend — usar Supabase Auth nativo para emails.** `[storage]` con file_size_limit="5MB" — para **Supabase Storage** (NO R2). `[api]` con schemas=["public","storage"]. | Config válido. Supabase CLI lo parsea sin errores. Auth usa email nativo. Storage configurado. |

---

## 03.6.2 — MIGRACIÓN 001: EXTENSIONES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.2.1 | Crear migración `001_extensions.sql` | [SQL] | Contenido del archivo: `CREATE EXTENSION IF NOT EXISTS "uuid-ossp"; CREATE EXTENSION IF NOT EXISTS "pgcrypto"; CREATE EXTENSION IF NOT EXISTS "pg_trgm"; ALTER DATABASE postgres SET timezone TO 'UTC';` — Las 3 extensiones + configuración de timezone. Corresponde a tareas 03.1.1.1 – 03.1.1.4 de SUBCAJA 03.1. | `supabase db reset` ejecuta sin errores. Las 3 extensiones aparecen en `pg_extension`. Timezone = UTC. |

---

## 03.6.3 — MIGRACIÓN 002: ENUMS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.3.1 | Crear migración `002_enums.sql` | [SQL] | Crear todos los ENUMs v2.0.0 en un solo archivo. **TaskStatus:** `('pending', 'in_progress', 'completed', 'failed')` — **4 valores, NO 'skipped'.** **DayStatus:** `('success', 'failed', 'death')` — **3 valores, SIN 'partial'.** **SubscriptionStatus:** `('trial', 'active', 'limbo', 'cancelled')`. **TaskCategory:** 17 categorías. **TaskArchetype:** `('WELLNESS', 'INTELLECTUAL', 'SOCIAL', 'FINANCIAL', 'LIFESTYLE')` — 5 arquetipos. **ToolType:** 9 herramientas (GOLDEN_RAZOR, POWER_SHAKE, CHARM_COLOGNE, BRAIN_SERUM, STREET_CRED_CARD, COLD_SHOWER_TIMER, MUSCLE_BANDS, VISION_BOARD, GRIND_PLAYLIST). **ItemRarity:** `('common', 'rare', 'epic', 'legendary')` — **4 valores, SIN 'uncommon'.** **ImageGenStatus:** `('pending', 'processing', 'completed', 'failed', 'retrying')` — **5 valores, added 'retrying'.** **NotificationType:** `('task_reminder', 'streak_at_risk', 'death_warning', 'level_up', 'item_unlocked', 'daily_summary', 'judgement_success', 'judgement_failed', 'avatar_death', 'avatar_recovered')` — **10 valores (NO 7).** **PaymentStatus:** `('pending', 'completed', 'failed', 'refunded')`. **TransactionType:** `('task_reward', 'level_up_bonus', 'purchase', 'death_penalty', 'inactivity_penalty')`. **LevelName:** `('INDIGENTE', 'REFUGIADO', 'MANTENIDO', 'ALUCÍN', 'PEÓN', 'HOMBRE COMÚN', 'INFLUYENTE', 'PUDIENTE', 'MILLONARIO', 'MAGNATE', 'ÉLITE', 'SEMI-DIOS')` — **12 valores (NO 13).** **Provider:** `('gemini')` — **Solo gemini. [fal.ai](http://fal.ai) PROHIBIDO.** | Cada enum creado con valores correctos v2.0.0. `SELECT enum_range(NULL::task_status_enum)` → 4 valores. `SELECT enum_range(NULL::day_status_enum)` → 3. `SELECT enum_range(NULL::item_rarity_enum)` → 4. `SELECT enum_range(NULL::notification_type_enum)` → 10. `SELECT enum_range(NULL::level_name_enum)` → 12. |

---

## 03.6.4 — MIGRACIÓN 003: TABLAS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.4.1 | Crear migración `003_tables.sql` — Tablas core | [SQL] | Crear las tablas principales en orden de dependencias. **profiles:** id UUID PK REFERENCES auth.users ON DELETE CASCADE, email TEXT NOT NULL, **nickname TEXT**, base_avatar_id SMALLINT CHECK(1-6), **oath_taken BOOLEAN DEFAULT FALSE**, timezone TEXT DEFAULT 'America/Mexico_City', **timezone_changed_at TIMESTAMPTZ**, **locale TEXT DEFAULT 'es-MX'**, **phone_encrypted TEXT**, onboarding_completed_at TIMESTAMPTZ, **deleted_at TIMESTAMPTZ**, 6 vectores (aura, jawline, wealth, physique, social NUMERIC(5,2) DEFAULT 0.00 CHECK(0-100), **env NUMERIC(4,2) DEFAULT 0.00 CHECK(0-20)**), overall_score NUMERIC(5,2) DEFAULT 0.00 CHECK(0-100), created_at, updated_at. **wallets:** id UUID PK, user_id UUID UNIQUE FK profiles, **btc_balance INTEGER DEFAULT 0 CHECK(>=0)** (NO 'balance'), btc_earned_today INTEGER DEFAULT 0, total_btc_earned INTEGER DEFAULT 0, total_btc_spent INTEGER DEFAULT 0, current_streak SMALLINT DEFAULT 0, longest_streak SMALLINT DEFAULT 0, current_hp SMALLINT DEFAULT 5 CHECK(0-**14**), **daily_cap INTEGER DEFAULT 2000** (NO 3500), version INTEGER DEFAULT 1, created_at, updated_at. **subscriptions:** id UUID PK, user_id UUID UNIQUE FK profiles, status subscription_status_enum DEFAULT 'trial', **plan TEXT CHECK(plan IN ('weekly','monthly','protocol_100'))** (NO 'yearly'), stripe_customer_id TEXT, stripe_subscription_id TEXT, trial_start TIMESTAMPTZ DEFAULT NOW(), trial_end TIMESTAMPTZ, current_period_start, current_period_end, created_at, updated_at. | Tablas creadas. profiles tiene nickname, oath_taken, locale, deleted_at, timezone_changed_at. Vectores escala 0-100 / ENV 0-20. wallets.btc_balance (NO balance). daily_cap DEFAULT 2000. HP CHECK(0-14). plan CHECK excluye 'yearly'. |
| 03.6.4.2 | Crear migración `003_tables.sql` — Tablas de gameplay | [SQL] | Continuación en mismo archivo. **daily_tasks:** id, user_id FK, category task_category_enum, archetype task_archetype_enum, title TEXT, description TEXT, **status task_status_enum DEFAULT 'pending'** (4 estados), difficulty TEXT, scheduled_date DATE, **started_at TIMESTAMPTZ**, completed_at TIMESTAMPTZ, **failed_at TIMESTAMPTZ**, btc_earned INTEGER DEFAULT 0, vector_changes JSONB, tool_type TEXT, tool_data JSONB, repetition_number SMALLINT DEFAULT 1, proof_url TEXT, idempotency_key TEXT, created_at, updated_at. UNIQUE(user_id, scheduled_date, category). **daily_logs:** id, user_id FK, log_date DATE, **day_status day_status_enum** (3 estados: success/failed/death, NO partial), tasks_completed SMALLINT DEFAULT 0, tasks_total SMALLINT DEFAULT 0, completion_percentage NUMERIC(5,2), btc_earned INTEGER DEFAULT 0, btc_lost INTEGER DEFAULT 0, vectors_snapshot JSONB (**6 vectores**), overall_score_snapshot NUMERIC(5,2), level_snapshot TEXT, hp_before SMALLINT, hp_after SMALLINT, **judgement_executed BOOLEAN DEFAULT FALSE**, **judgement_at TIMESTAMPTZ**, created_at. UNIQUE(user_id, log_date). | daily_tasks con 4 status. daily_logs con 3 day_status. judgement_executed flag. UNIQUE constraints. |
| 03.6.4.3 | Crear migración `003_tables.sql` — Tablas de tienda e inventario | [SQL] | Continuación. **store_items:** id UUID PK, name TEXT NOT NULL, description TEXT, category TEXT, **rarity item_rarity_enum DEFAULT 'common'** (4 niveles, SIN uncommon), price_btc INTEGER CHECK(>0), level_required SMALLINT DEFAULT 0 CHECK(0-**11**) (index de 12 niveles), vector_requirements JSONB, streak_required SMALLINT DEFAULT 0, ia_token TEXT, image_preview_url TEXT, is_premium BOOLEAN DEFAULT FALSE, is_active BOOLEAN DEFAULT TRUE, max_per_user SMALLINT, vectors_boosted JSONB, boost_percentage NUMERIC(5,2), duration_hours INTEGER, max_stack SMALLINT DEFAULT 1, category_affinity JSONB, created_at. **inventory:** id UUID PK, user_id FK, item_id UUID FK store_items, quantity INTEGER DEFAULT 1, is_equipped BOOLEAN DEFAULT FALSE, equipped_at TIMESTAMPTZ, locked_by_death BOOLEAN DEFAULT FALSE, purchased_at TIMESTAMPTZ DEFAULT NOW(). UNIQUE(user_id, item_id). | store_items rarity 4 valores. level_required max 11 (NO 12/13). inventory con quantity, locked_by_death. |
| 03.6.4.4 | Crear migración `003_tables.sql` — Tablas de soporte | [SQL] | Continuación. **tool_progress:** id, user_id FK, tool_type TEXT, total_sessions INTEGER DEFAULT 0, total_duration_minutes INTEGER DEFAULT 0, current_streak SMALLINT DEFAULT 0, best_streak SMALLINT DEFAULT 0, last_session_at TIMESTAMPTZ, tool_specific_data JSONB, created_at, updated_at. UNIQUE(user_id, tool_type). **btc_transactions:** id UUID PK, user_id FK, type transaction_type_enum, amount INTEGER NOT NULL, description TEXT, metadata JSONB, balance_after INTEGER, created_at DEFAULT NOW(). **level_history:** id UUID PK, user_id FK, old_level TEXT, new_level TEXT, overall_score_at_change NUMERIC(5,2), changed_at TIMESTAMPTZ DEFAULT NOW(). **avatar_deaths:** id UUID PK, user_id FK, death_number SMALLINT, btc_lost INTEGER, penalty_pct NUMERIC(3,2), vectors_before JSONB, vectors_after JSONB, **is_hibernation BOOLEAN DEFAULT FALSE**, **hibernation_ends_at TIMESTAMPTZ**, recovered BOOLEAN DEFAULT FALSE, recovered_at TIMESTAMPTZ, created_at DEFAULT NOW(). **activity_logs:** id, user_id FK, action TEXT, entity_type TEXT, entity_id UUID, metadata JSONB, created_at. **image_generation_queue:** id, user_id FK, base_avatar_id SMALLINT CHECK(1-6), vectors_snapshot JSONB, equipped_items JSONB, status **image_gen_status_enum DEFAULT 'pending'** (5 estados), priority SMALLINT DEFAULT 5, **provider TEXT DEFAULT 'gemini'** (NO 'fal-ai'), request_id TEXT, result_url TEXT, error_message TEXT, attempts SMALLINT DEFAULT 0, max_attempts SMALLINT DEFAULT 3, prompt_used TEXT, created_at, processed_at. **notifications:** id, user_id FK, type **notification_type_enum** (10 tipos), title TEXT, body TEXT, metadata JSONB, is_read BOOLEAN DEFAULT FALSE, read_at TIMESTAMPTZ, created_at. **idempotency_keys:** id, key TEXT UNIQUE, user_id FK, action TEXT, result JSONB, status TEXT CHECK('processing','completed','failed'), created_at, expires_at DEFAULT NOW()+24h. **payments:** id, user_id FK, stripe_payment_intent_id TEXT, stripe_invoice_id TEXT, amount_cents INTEGER, currency TEXT DEFAULT 'usd', status payment_status_enum DEFAULT 'pending', plan TEXT, metadata JSONB, created_at. | Todas las tablas creadas. btc_transactions, level_history, avatar_deaths son tablas nuevas v2.0.0. image_generation_queue provider='gemini'. notifications 10 tipos. image_gen_status 5 estados. |

---

## 03.6.5 — MIGRACIÓN 004: ÍNDICES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.5.1 | Crear migración `004_indexes.sql` | [SQL] | Todos los índices de SUBCAJA 03.1.4 + índices nuevos para tablas v2.0.0. **Índices originales (actualizados):** idx_profiles_email (UNIQUE), idx_wallets_user_id (UNIQUE), idx_subscriptions_user_id (UNIQUE), idx_subscriptions_stripe_customer (parcial WHERE NOT NULL), idx_daily_tasks_user_date(user_id, scheduled_date), idx_daily_tasks_pending (parcial WHERE status='pending'), idx_daily_tasks_idempotency (UNIQUE parcial WHERE NOT NULL), idx_daily_logs_user_date(user_id, log_date), idx_daily_logs_date_desc(user_id, log_date DESC), idx_inventory_user(user_id, is_equipped), idx_tool_progress_user_tool (UNIQUE), idx_activity_logs_user_date(user_id, created_at DESC), idx_image_queue_pending (parcial WHERE status='pending'), idx_notifications_unread (parcial WHERE is_read=FALSE), idx_idempotency_key (UNIQUE), idx_idempotency_expires (parcial WHERE status='processing'), idx_payments_stripe (parcial WHERE NOT NULL). **Índices NUEVOS v2.0.0:** `CREATE INDEX idx_btc_transactions_user ON btc_transactions(user_id, created_at DESC);` `CREATE INDEX idx_btc_transactions_type ON btc_transactions(user_id, type);` `CREATE INDEX idx_level_history_user ON level_history(user_id, changed_at DESC);` `CREATE INDEX idx_avatar_deaths_user ON avatar_deaths(user_id, created_at DESC);` `CREATE INDEX idx_avatar_deaths_active ON avatar_deaths(user_id) WHERE recovered = FALSE;` `CREATE INDEX idx_profiles_oath ON profiles(oath_taken) WHERE oath_taken = TRUE;` `CREATE INDEX idx_profiles_deleted ON profiles(deleted_at) WHERE deleted_at IS NOT NULL;` `CREATE INDEX idx_daily_logs_judgement ON daily_logs(user_id, log_date) WHERE judgement_executed = FALSE;` — **Total: 25 índices (vs 18 original).** | 25 índices creados. Parciales funcionan correctamente. UNIQUE constraints respetados. Nuevos índices para tablas v2.0.0 presentes. |

---

## 03.6.6 — MIGRACIÓN 005: TRIGGERS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.6.1 | Crear migración `005_triggers.sql` — updated_at automático | [SQL] | Función `fn_set_updated_at()`  • triggers en: profiles, wallets, subscriptions, daily_tasks, tool_progress. 1 función + 5 triggers = 6 objetos. Idéntico a SUBCAJA 03.1.5. | UPDATE en cualquiera de las 5 tablas actualiza updated_at automáticamente. |
| 03.6.6.2 | Crear migración `005_triggers.sql` — validaciones | [SQL] | Continuación. **fn_validate_vector_range:** Valida 6 vectores en profiles. Rangos v2.0.0: aura/jawline/wealth/physique/social → 0.00-100.00 (NO 0-50). **env → 0.00-20.00 (NO 1-10).** Trigger BEFORE INSERT OR UPDATE ON profiles. **fn_validate_daily_cap:** Clampea btc_earned_today al daily_cap en wallets. Cap base **2,000** (NO 3,500). Trigger BEFORE UPDATE ON wallets. **fn_validate_hibernation:** Previene cambios de vectores en usuarios con hibernación activa. Verifica avatar_deaths WHERE is_hibernation=true AND recovered=false AND hibernation_ends_at > NOW(). Trigger BEFORE UPDATE ON profiles (vectores). | Vectores fuera de rango rechazados (escala 0-100 / 0-20). Daily cap clampea correctamente a 2000 base. Hibernados no pueden cambiar vectores. |
| 03.6.6.3 | Crear migración `005_triggers.sql` — auto-creación nuevo usuario | [SQL] | Continuación. **fn_handle_new_user:** SECURITY DEFINER SET search_path = public. Se ejecuta AFTER INSERT ON auth.users. Crea automáticamente: 1) profiles con email, nickname=NULL, oath_taken=false, timezone='America/Mexico_City', locale='es-MX'. 2) wallets con btc_balance=0, current_hp=**5** (HP inicial), daily_cap=**2000**, current_streak=0. 3) subscriptions con status='trial', trial_end=NOW()+5 days. **NO crear tool_progress aquí** — se crea durante onboarding cuando el usuario selecciona personaje. **NO crear avatar_states** — vectores ahora viven en profiles directamente. | Crear usuario en auth.users genera: 1 profile (oath_taken=false), 1 wallet (hp=5, cap=2000), 1 subscription (trial, +5 days). **Verificar que NO crea avatar_states ni tool_progress (cambio v2.0.0).** |
| 03.6.6.4 | Crear migración `005_triggers.sql` — timezone cooldown | [SQL] | **NUEVO v2.0.0.** Trigger function `fn_validate_timezone_change`: BEFORE UPDATE ON profiles. Si OLD.timezone != NEW.timezone → verificar que OLD.timezone_changed_at IS NULL O que `NOW() - OLD.timezone_changed_at > INTERVAL '24 hours'`. Si no cumple → RAISE EXCEPTION 'Timezone change cooldown: 24h required'. Si cumple → SET NEW.timezone_changed_at = NOW(). Previene abuse de cambio de timezone para duplicar recompensas diarias. | Cambio de timezone rechazado si <24h desde último cambio. Primer cambio siempre permitido. timezone_changed_at actualizado automáticamente. |

---

## 03.6.7 — MIGRACIONES 006-010: FUNCIONES

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.7.1 | Crear migración `006_functions_auxiliary.sql` | [SQL] | Todas las funciones de SUBCAJA 03.2.1 (13 funciones auxiliares puras): fn_clamp, fn_calculate_overall_score (**fórmula con ENV×5**), fn_determine_level (**12 niveles**), fn_get_level_index, fn_calculate_btc_multiplier (**ADITIVO**), fn_calculate_hp_max (**max 14**), fn_calculate_daily_cap (**base 2000**), fn_get_vector_weights, fn_get_death_btc_penalty, fn_get_streak_bonus (**aditivo**), fn_get_subscription_bonus (**3 planes**), fn_get_diminishing_factor, fn_get_health_penalty. Usar `CREATE OR REPLACE FUNCTION` para idempotencia. | 13 funciones creadas. Todas con valores v2.0.0 correctos. |
| 03.6.7.2 | Crear migración `007_functions_core.sql` | [SQL] | Funciones core de SUBCAJA 03.2.2-03.2.3: fn_get_task_config (17 categorías), fn_get_task_categories_by_archetype (5 arquetipos), fn_get_difficulty_config (4 niveles), fn_get_tools_config (9 herramientas, **4 rarities**), fn_get_characters_config (6 personajes), fn_complete_task_transaction (**Result Monad ok/value**, multiplicador aditivo, cap 2000), fn_start_task, fn_fail_task. Todas SECURITY DEFINER donde aplica. | Funciones core creadas. Task completion usa multiplicador aditivo. Result monad ok/value. |
| 03.6.7.3 | Crear migración `008_functions_judgement.sql` | [SQL] | Funciones de SUBCAJA 03.2.4-03.2.6: fn_process_judgement_night (**BINARIO ≥80%/<80%**, advisory lock), fn_process_judgement_batch (timezone-aware), fn_execute_avatar_death (**AURA preserva 30%**, hibernación 72h en 3ª+ muerte), fn_check_hibernation_status, fn_recover_from_death, fn_apply_daily_vector_decay, fn_apply_inactivity_penalty. | Judgement binario. Muerte con penalties correctas. Hibernación 72h. Decay funcional. |
| 03.6.7.4 | Crear migración `009_functions_store.sql` | [SQL] | Funciones de SUBCAJA 03.2.7-03.2.10: fn_generate_daily_tasks (7-10 tareas por nivel), fn_enrich_task_with_ai_prompt (payload para **Gemini**, NO [fal.ai](http://fal.ai)), fn_validate_daily_task_limits, fn_reward_btc, fn_deduct_btc, fn_reset_daily_btc_counter, fn_calculate_btc_reward, fn_recalculate_env (**escala 0-20**), fn_purchase_item, fn_equip_item (**max 3**), fn_unequip_item, fn_get_store_catalog, fn_unlock_death_items. | Funciones de tienda y economía creadas. ENV escala 0-20. Max 3 equipadas. |
| 03.6.7.5 | Crear migración `010_functions_misc.sql` | [SQL] | Funciones de SUBCAJA 03.2.11-03.2.18: fn_complete_onboarding (**6 personajes**, nickname, oath_taken), fn_get_level_health_bonus, fn_get_level_btc_bonus (**12 niveles**), fn_process_level_up, fn_cleanup_expired_idempotency_keys, fn_cleanup_old_notifications, fn_cleanup_old_activity_logs, fn_get_user_full_state (**btc_balance**, 12 niveles, 3 planes), fn_get_user_history, fn_build_image_prompt (provider **gemini**), fn_queue_image_generation (**Supabase Storage**), fn_update_profile (timezone cooldown), fn_soft_delete_account, fn_create_notification (**10 tipos**), fn_mark_notifications_read, fn_process_subscription_change (**NO yearly**), fn_process_trial_expiration, fn_handle_payment_failed. | Todas las funciones misc creadas. Valores v2.0.0. |

---

## 03.6.8 — MIGRACIONES 011-012: RLS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.8.1 | Crear migración `011_rls_enable.sql` | [SQL] | `ALTER TABLE ... ENABLE ROW LEVEL SECURITY;` para las **16 tablas**: profiles, wallets, subscriptions, daily_tasks, daily_logs, store_items, inventory, tool_progress, activity_logs, image_generation_queue, notifications, idempotency_keys, payments, btc_transactions, level_history, avatar_deaths. | 16 tablas con RLS habilitado. |
| 03.6.8.2 | Crear migración `012_rls_policies.sql` | [SQL] | Todas las policies de SUBCAJA 03.3. **Policies SELECT** para las 16 tablas (auth.uid() = user_id excepto store_items que es público autenticado). **Policies UPDATE** solo para: profiles (nickname/timezone/locale) y notifications (marcar leída). **NO policies UPDATE** para: wallets, subscriptions, daily_tasks, daily_logs, tool_progress, activity_logs, image_generation_queue, idempotency_keys, payments, btc_transactions, level_history, avatar_deaths, store_items, inventory. **Policy INSERT** solo para profiles (self). **NO policies INSERT** para el resto. | Policies creadas. Tablas críticas sin UPDATE policy. Solo 2 tablas con UPDATE. Verificación global pasa (03.3.18). |

---

## 03.6.9 — MIGRACIÓN 013: SEED DATA

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.9.1 | Crear migración `013_seed_store_items.sql` — Herramientas | [SQL] | Insertar las **9 herramientas** en store_items con datos completos de fn_get_tools_config. Cada INSERT incluye: name, description, rarity (**4 niveles: common/rare/epic/legendary**), price_btc, level_required (index 0-11), vectors_boosted JSONB, boost_percentage, duration_hours, max_stack, category_affinity JSONB, ia_token para generación de imagen, is_active=true. **Las 9 herramientas:** 1) GOLDEN_RAZOR — common, 500 BTC, level 0, boost JAWLINE+AURA. 2) POWER_SHAKE — common, 300 BTC, level 0, boost PHYSIQUE. 3) CHARM_COLOGNE — rare, 1500 BTC, level 3, boost SOCIAL+AURA. 4) BRAIN_SERUM — rare, 2000 BTC, level 4, boost WEALTH. 5) STREET_CRED_CARD — epic, 5000 BTC, level 6, boost SOCIAL+WEALTH. 6) COLD_SHOWER_TIMER — common, 400 BTC, level 0, boost JAWLINE+PHYSIQUE. 7) MUSCLE_BANDS — rare, 1800 BTC, level 3, boost PHYSIQUE+JAWLINE. 8) VISION_BOARD — epic, 4000 BTC, level 5, boost AURA+WEALTH. 9) GRIND_PLAYLIST — legendary, 10000 BTC, level 8, boost ALL vectors. Usar `INSERT ... ON CONFLICT DO NOTHING` para idempotencia. | 9 items insertados. Rarities correctas (4 niveles). Precios y niveles coherentes. ia_tokens presentes. |
| 03.6.9.2 | Crear seed data para Supabase Storage buckets | [SQL/CONFIG] | Crear buckets en **Supabase Storage** (NO Cloudflare R2): 1) `avatars` — imágenes de avatar generadas por IA (**Gemini**). Max file size 2MB. Público para lectura (URLs firmadas). 2) `proofs` — pruebas fotográficas de tareas completadas. Max file size 5MB. Privado (solo propietario). 3) `assets` — assets estáticos del juego (personajes base, items, UI). Público. SQL para crear buckets via Supabase: `INSERT INTO storage.buckets (id, name, public, file_size_limit) VALUES ('avatars', 'avatars', true, 2097152), ('proofs', 'proofs', false, 5242880), ('assets', 'assets', true, null) ON CONFLICT DO NOTHING;`  • RLS policies para cada bucket. | 3 buckets creados. avatars público. proofs privado. assets público. File limits correctos. |
| 03.6.9.3 | Crear RLS policies para Storage buckets | [SQL] | **Bucket avatars:** SELECT para authenticated (ver avatares propios y de otros para leaderboard). INSERT solo vía service_role (worker de imagen). **Bucket proofs:** SELECT/INSERT para authenticated WHERE auth.uid()::text = (storage.foldername(name))[1]. Cada usuario solo ve/sube en su propia carpeta: `proofs/{user_id}/`. **Bucket assets:** SELECT para todos (público). INSERT/UPDATE/DELETE solo service_role. | Policies de storage correctas. Usuario no puede acceder a proofs de otro. |

---

## 03.6.10 — SCRIPTS DE VERIFICACIÓN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.10.1 | Crear script `verify_schema.sql` | [SQL] | Script ejecutable post-migración que verifica la integridad completa del schema. **Verificaciones:** 1) 16 tablas existen en schema public. 2) Todos los ENUMs tienen valores correctos v2.0.0 (TaskStatus=4, DayStatus=3, ItemRarity=4, NotificationType=10, LevelName=12, ImageGenStatus=5). 3) 25 índices existen. 4) 16 tablas con RLS habilitado. 5) Policies: solo 2 tablas con UPDATE policy (profiles, notifications). 6) Functions: todas las SECURITY DEFINER existen con prosecdef=TRUE. 7) Triggers: fn_set_updated_at en 5 tablas, fn_validate_vector_range, fn_validate_daily_cap, fn_validate_hibernation, fn_handle_new_user, fn_validate_timezone_change. 8) Extensions: uuid-ossp, pgcrypto, pg_trgm. 9) Storage buckets: avatars, proofs, assets. Script usa `DO $$ BEGIN ... RAISE NOTICE 'CHECK: ...'; END $$;` para reportar resultados. | Script ejecuta sin errores. Todos los checks pasan. Output: "ALL CHECKS PASSED". |
| 03.6.10.2 | Crear script `verify_functions.sql` | [SQL] | Script que ejecuta tests unitarios de las funciones auxiliares con valores conocidos. **Tests:** 1) `fn_clamp(105, 0, 100)` = 100. 2) `fn_calculate_overall_score(100,100,100,100,100,20)` = 100.00. 3) `fn_determine_level(0)` = 'INDIGENTE'. 4) `fn_determine_level(98)` = 'SEMI-DIOS'. 5) `fn_get_level_index('SEMI-DIOS')` = 11 (NO 12). 6) `fn_calculate_daily_cap` para sin sub → 2000 (NO 3500). 7) `fn_get_streak_bonus(15)` = 1.5 (aditivo, NO 2.5). 8) `fn_get_subscription_bonus('weekly')` = 0.05. 9) `fn_get_death_btc_penalty(0)` = 0.30. 10) `fn_get_diminishing_factor(1)` = 1.0. Cada test usa `ASSERT` o `RAISE EXCEPTION` si falla. | Todos los tests pasan. Valores correctos v2.0.0. |
| 03.6.10.3 | Crear script `verify_rls.sql` | [SQL] | Script que verifica aislamiento RLS. Requiere 2 usuarios de prueba. **Tests:** 1) Usuario A no puede SELECT datos de B en: profiles, wallets, daily_tasks, btc_transactions, notifications. 2) Usuario A no puede UPDATE wallets, daily_tasks, subscriptions (tablas sin UPDATE policy). 3) store_items visible para authenticated. 4) SECURITY DEFINER functions pueden operar cross-table sin RLS errors. | Aislamiento verificado. Tablas protegidas. |
| 03.6.10.4 | Crear script `verify_seed.sql` | [SQL] | Verifica que seed data es correcta. **Tests:** 1) `SELECT COUNT(*) FROM store_items WHERE is_active = true` = 9 (herramientas). 2) Cada herramienta tiene rarity IN ('common','rare','epic','legendary') — NO 'uncommon'. 3) `SELECT COUNT(DISTINCT rarity) FROM store_items` ≥ 3 (al menos 3 de las 4 rarities usadas). 4) Storage buckets existen: `SELECT COUNT(*) FROM storage.buckets WHERE id IN ('avatars','proofs','assets')` = 3. | 9 herramientas activas. Rarities correctas. 3 buckets. |

---

## 03.6.11 — CONFIGURACIÓN DE SUPABASE AUTH

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.6.11.1 | Configurar Supabase Auth email templates | [CONFIG] | **Supabase Auth nativo (NO Resend).** Configurar email templates en Supabase Dashboard → Authentication → Email Templates. Templates requeridos: 1) **Confirm signup** — con branding metameN100. 2) **Magic link** — para login sin password. 3) **Change email** — confirmación de cambio. 4) **Reset password** — recuperación. Todos en español (es-MX) con tono masculino motivacional acorde a la marca. Variables disponibles: `{{ .ConfirmationURL }}`, `{{ .Token }}`, `{{ .SiteURL }}`. **NO usar Resend, NO usar SendGrid, NO usar custom SMTP.** | Templates configurados en Supabase Dashboard. Emails se envían correctamente al registrar usuario. Branding metameN100 visible. |
| 03.6.11.2 | Configurar Supabase Auth providers | [CONFIG] | En Supabase Dashboard → Authentication → Providers. Habilitar: 1) **Email** — con confirm email enabled. 2) **Google OAuth** (opcional para fase 2). Configurar redirect URLs para Next.js: `http://localhost:3000/auth/callback`, `https://[production-url]/auth/callback`. JWT expiry: 3600s (1 hora). Refresh token rotation: enabled. | Email auth funciona. Redirect URLs configurados. JWT expiry correcto. |

---
# ══════════════════════════════════════════════════════════════

# SUBCAJA 03.7 — EXTERNAL INTEGRATIONS

# Inngest · Gemini Image Pipeline · Stripe Webhooks · Supabase Auth · Supabase Storage · Upstash Redis/BullMQ

# 48 TAREAS

# ══════════════════════════════════════════════════════════════

---

## 03.7.1 — INNGEST: CONFIGURACIÓN BASE

| ID | Título | Tipo | Detalle | Validación |  |  |
| --- | --- | --- | --- | --- | --- | --- |
| 03.7.1.1 | Instalar y configurar Inngest SDK | [TYPESCRIPT] | `npm install inngest`. Crear archivo `src/lib/inngest/client.ts`. Exportar instancia: `export const inngest = new Inngest({ id: 'metamen100', schemas: new EventSchemas().fromRecord<Events>({}) });`. Configurar variables de entorno: `INNGEST_EVENT_KEY`, `INNGEST_SIGNING_KEY`. El client es singleton — importar siempre desde este archivo. | Paquete instalado. Client exportado. Variables en `.env.local`. Import funciona sin errores. |  |  |
| 03.7.1.2 | Definir tipos de eventos Inngest | [TYPESCRIPT] | Crear `src/lib/inngest/events.ts`. Definir interfaz `Events` con todos los eventos del sistema: `'app/judgement.scheduled'` (data: { timezone: string, batch_size: number }), `'app/judgement.process-user'` (data: { user_id: string, log_date: string }), `'app/avatar.death'` (data: { user_id: string, death_number: number }), `'app/avatar.generate-image'` (data: { user_id: string, queue_id: string, priority: number }), `'app/daily.generate-tasks'` (data: { user_id: string, date: string }), `'app/daily.enrich-task'` (data: { task_id: string, user_id: string }), `'app/cleanup.run'` (data: { type: 'idempotency' \ | 'notifications' \ | 'activity_logs' }), `'app/vector.decay'` (data: { user_id: string }), `'app/subscription.trial-expiring'` (data: { user_id: string, days_remaining: number }), `'app/subscription.payment-failed'` (data: { user_id: string, stripe_invoice_id: string }), `'app/hibernation.check'` (data: { user_id: string }), `'app/btc.reset-daily'` (data: {}). Todos tipados con `EventSchemas`. | Tipos compilan sin errores. Cada evento tiene data tipada. No hay `any`. |
| 03.7.1.3 | Crear API route para Inngest serve | [TYPESCRIPT] | Crear `src/app/api/inngest/route.ts`. Usar `serve({ client: inngest, functions: [...allFunctions] })`. Exportar como `GET` y `POST`. Importar todas las funciones Inngest desde barrel `src/lib/inngest/functions/index.ts`. En desarrollo: Inngest Dev Server en `http://localhost:8288`. En producción: Inngest Cloud con signing key. | Route responde a GET (dashboard) y POST (events). Dev server muestra las funciones registradas. |  |  |

---

## 03.7.2 — INNGEST: CRON FUNCTIONS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.7.2.1 | Crear función `judgement-night-cron` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/judgement-night.ts`. Cron: `'0 0 * * *'` (medianoche UTC). Lógica: 1) Obtener lista de timezones únicas de profiles. 2) Para cada timezone donde sea medianoche local (±30 min): enviar evento `'app/judgement.scheduled'` con timezone y batch_size=50. **Judgement es BINARIO:** ≥80% tareas completadas = success (+1 HP, streak+1), <80% = failed (-1 HP, streak=0). Si HP llega a 0 → muerte de avatar. Usa `inngest.createFunction({ id: 'judgement-night-cron', name: 'Judgement Night Cron' }, { cron: '0 * * * *' })` — cada hora checa qué timezones están en medianoche. | Cron ejecuta cada hora. Solo procesa timezones en medianoche. Eventos emitidos correctamente. |
| 03.7.2.2 | Crear función `judgement-process-batch` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/judgement-batch.ts`. Trigger: evento `'app/judgement.scheduled'`. Lógica: 1) Query usuarios por timezone que NO tienen judgement_executed=true para hoy. 2) Fan-out: emitir `'app/judgement.process-user'` para cada usuario (max batch_size). 3) Concurrency limit: `{ key: 'event.data.timezone', limit: 5 }`. 4) Retry: `{ attempts: 3, backoff: 'exponential' }`. Usa supabaseAdmin (service_role). | Batch procesa usuarios correctos por timezone. Concurrency respetada. Retries funcionan. |
| 03.7.2.3 | Crear función `judgement-process-user` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/judgement-user.ts`. Trigger: evento `'app/judgement.process-user'`. Lógica: 1) Llamar `fn_process_judgement_night(user_id, log_date)` vía supabaseAdmin.rpc(). 2) Si resultado indica HP=0 → emitir `'app/avatar.death'`. 3) Si resultado indica level_up → loguear en level_history. 4) Marcar daily_log.judgement_executed=true, judgement_at=NOW(). **Result Monad:** Verificar `result.ok === true` antes de proceder. Si `ok === false` → loguear error, NO reintentar (idempotencia). Timeout: 30s. | Usuario procesado. Judgement binario aplicado. HP actualizado. Muerte emitida si HP=0. |
| 03.7.2.4 | Crear función `daily-vector-decay-cron` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/vector-decay.ts`. Cron: ejecutar junto con judgement (después). Para usuarios que NO completaron ≥80% hoy: aplicar vector decay vía `fn_apply_daily_vector_decay`. Decay rate: -0.5 por vector no trabajado. Vectores no bajan de 0. **ENV recalculado** después del decay vía `fn_recalculate_env`. | Decay aplicado solo a usuarios que fallaron. Vectores no negativos. ENV recalculado. |
| 03.7.2.5 | Crear función `daily-btc-reset-cron` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/btc-reset.ts`. Cron: `'0 0 * * *'` por timezone (misma lógica que judgement). Lógica: Para cada usuario cuya medianoche local acaba de pasar → `fn_reset_daily_btc_counter(user_id)`. Resetea btc_earned_today=0. **Cap diario base: 2,000 BTC** (NO 3,500). | btc_earned_today reseteado a 0. Ejecuta por timezone. |
| 03.7.2.6 | Crear función `cleanup-cron` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/cleanup.ts`. Cron: `'0 3 * * *'` (3 AM UTC diario). Ejecutar: 1) `fn_cleanup_expired_idempotency_keys()` — elimina keys >24h. 2) `fn_cleanup_old_notifications()` — elimina leídas >30 días. 3) `fn_cleanup_old_activity_logs()` — elimina >90 días. Cada cleanup como step separado para tracking. | Cleanup ejecuta. Registros viejos eliminados. |
| 03.7.2.7 | Crear función `trial-expiration-check-cron` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/trial-check.ts`. Cron: `'0 9 * * *'` (9 AM UTC diario). Lógica: 1) Query subscriptions WHERE status='trial' AND trial_end <= NOW() + INTERVAL '1 day'. 2) Para usuarios a 1 día de expirar → emitir `'app/subscription.trial-expiring'`. 3) Para usuarios con trial_end <= NOW() → llamar `fn_process_trial_expiration(user_id)`. Status cambia a 'limbo'. Crear notificación. **Planes disponibles post-trial: weekly $2.99, monthly $9.99, protocol_100 $29.99 (NO yearly).** | Trials expirados → status 'limbo'. Notificación creada. |
| 03.7.2.8 | Crear función `hibernation-check-cron` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/hibernation-check.ts`. Cron: `'*/30 * * * *'` (cada 30 min). Lógica: Query avatar_deaths WHERE is_hibernation=true AND recovered=false AND hibernation_ends_at <= NOW(). Para cada uno → llamar `fn_recover_from_death(user_id)`. Marcar recovered=true, recovered_at=NOW(). Crear notificación tipo 'avatar_recovered'. **Hibernación: 72h en 3ª+ muerte.** | Usuarios recuperados después de 72h. Notificación enviada. |

---

## 03.7.3 — INNGEST: EVENT-DRIVEN FUNCTIONS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.7.3.1 | Crear función `generate-daily-tasks` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/generate-tasks.ts`. Trigger: evento `'app/daily.generate-tasks'`. Lógica: 1) Llamar `fn_generate_daily_tasks(user_id, date)` para generar 7-10 tareas según nivel. 2) Para cada tarea generada → emitir `'app/daily.enrich-task'` para enriquecer con IA. 3) Throttle: `{ key: 'event.data.user_id', limit: 1, period: '1h' }` — máximo 1 generación por hora por usuario. | Tareas generadas (7-10). Eventos de enriquecimiento emitidos. Throttle funciona. |
| 03.7.3.2 | Crear función `enrich-task-with-ai` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/enrich-task.ts`. Trigger: evento `'app/daily.enrich-task'`. Lógica: 1) Obtener task data + user context (nivel, vectores, herramientas equipadas). 2) Llamar `fn_enrich_task_with_ai_prompt(task_id)` para obtener prompt base. 3) Llamar **Gemini 2.5 Flash** (NO [fal.ai](http://fal.ai)) para generar descripción personalizada. 4) Update daily_tasks con description enriquecida. Retry: 3 intentos con backoff exponencial. Timeout: 15s por llamada a Gemini. **Rate limit Gemini: respetar 60 RPM** vía throttle Inngest. | Tarea enriquecida con descripción personalizada. Gemini llamado (NO [fal.ai](http://fal.ai)). Rate limit respetado. |
| 03.7.3.3 | Crear función `process-avatar-death` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/avatar-death.ts`. Trigger: evento `'app/avatar.death'`. Lógica (steps secuenciales): **Step 1:** `fn_execute_avatar_death(user_id)` — Aplicar penalización BTC (1ª=30%, 2ª=40%, 3ª+=50%). **AURA preserva 30%.** Otros vectores van a 0. **Step 2:** Si death_number ≥ 3 → marcar is_hibernation=true, hibernation_ends_at = NOW() + **72h**. Bloquear inventario (locked_by_death=true). **Step 3:** Crear notificación tipo 'avatar_death'. **Step 4:** Registrar en avatar_deaths. **Step 5:** Si NO hibernación → emitir `'app/avatar.generate-image'` para regenerar avatar con vectores reseteados. Concurrency: `{ key: 'event.data.user_id', limit: 1 }`. | Muerte procesada. BTC penalizado. Vectores reseteados (AURA 30%). Hibernación si 3ª+. Notificación creada. |
| 03.7.3.4 | Crear función `generate-avatar-image` | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/generate-image.ts`. Trigger: evento `'app/avatar.generate-image'`. Lógica: **Step 1:** Obtener datos del queue (image_generation_queue). **Step 2:** Llamar `fn_build_image_prompt(user_id)` para construir prompt completo (personaje base + vectores + herramientas equipadas). **Step 3:** Enviar a **Gemini 2.5 Flash** image generation (NO [fal.ai](http://fal.ai)). **Step 4:** Recibir imagen → subir a **Supabase Storage** bucket 'avatars' (NO R2). **Step 5:** Actualizar queue status='completed', result_url=URL de storage. **Step 6:** Actualizar profiles con nueva avatar_url. Si falla → status='failed' si attempts ≥ max_attempts(3), status='retrying' si attempts < 3. Retry vía Inngest: `{ attempts: 3, backoff: { type: 'exponential', minTimeout: 5000 } }`. Rate limit: `{ key: 'global', limit: 10, period: '1m' }` para respetar límites de Gemini. | Imagen generada vía Gemini. Subida a Supabase Storage. Queue actualizado. Avatar URL en profiles. Retries funcionan. |

---

## 03.7.4 — GEMINI IMAGE PIPELINE

| ID | Título | Tipo | Detalle | Validación |  |
| --- | --- | --- | --- | --- | --- |
| 03.7.4.1 | Crear cliente Gemini | [TYPESCRIPT] | Archivo: `src/lib/gemini/client.ts`. Usar `@google/generative-ai` SDK. Configurar: `const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!)`. Modelo para texto: `gemini-2.5-flash`. Modelo para imágenes: `gemini-2.5-flash` con image generation capability. **PROHIBIDO: [fal.ai](http://fal.ai), DALL-E, Midjourney, Stable Diffusion.** Exportar funciones: `generateText(prompt, options)`, `generateImage(prompt, options)`. Ambas retornan **Result Monad** `{ ok: true, value: T } | { ok: false, error: E }`. | Cliente compila. API key configurada. Solo Gemini. Result Monad en retornos. |
| 03.7.4.2 | Crear módulo de prompt building | [TYPESCRIPT] | Archivo: `src/lib/gemini/prompts.ts`. Funciones: 1) `buildAvatarPrompt(character, vectors, items)` — Construye prompt para generación de avatar. Usa: personaje base (1 de **6**: EL_RASTAS, EL_GUARRO, EL_PECAS, EL_GREÑAS, EL_GUERO, EL_LIC), niveles de vectores (AURA 0-100, JAWLINE 0-100, WEALTH 0-100, PHYSIQUE 0-100, SOCIAL 0-100, **ENV 0-20**), herramientas equipadas (ia_token de cada item). 2) `buildTaskEnrichmentPrompt(task, userContext)` — Prompt para personalizar descripción de tarea. 3) Constantes de prompt: system instructions, style guidelines, safety settings. **Idioma de prompts: español (es-MX)** acorde al tono de la app. | Prompts generados correctamente. Vectores en escalas correctas. 6 personajes cubiertos. |  |
| 03.7.4.3 | Crear módulo de image processing | [TYPESCRIPT] | Archivo: `src/lib/gemini/image-processing.ts`. Funciones: 1) `processGeneratedImage(imageBuffer)` — Validar formato (PNG/JPEG/WebP), redimensionar si necesario (max 1024x1024), comprimir. 2) `uploadToSupabaseStorage(imageBuffer, userId, filename)` — Subir a bucket 'avatars' en **Supabase Storage** (NO R2). Path: `avatars/{user_id}/{timestamp}.webp`. Retorna URL pública. 3) `deleteOldAvatars(userId)` — Limitar a últimas 5 imágenes por usuario para no explotar storage. Usa supabaseAdmin para operaciones de storage. | Imagen procesada y subida. URL accesible públicamente. Viejas imágenes eliminadas. |  |
| 03.7.4.4 | Crear rate limiter para Gemini | [TYPESCRIPT] | Archivo: `src/lib/gemini/rate-limiter.ts`. Implementar rate limiting usando **Upstash Redis** (SE MANTIENE per user override). Usar `@upstash/ratelimit` con sliding window: 60 requests per minute (Gemini free tier). Key: `gemini:rpm`. Funciones: `checkGeminiRateLimit()` → `{ ok: boolean, remaining: number, reset: number }`. Si rate limited → retornar Result Monad `{ ok: false, error: { code: 'RATE_LIMITED', retryAfter: reset } }`. Inngest manejará el retry automáticamente. | Rate limit funciona. Requests se limitan a 60/min. Upstash Redis usado como backend. |  |

---

## 03.7.5 — STRIPE WEBHOOKS

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.7.5.1 | Crear API route para Stripe webhooks | [TYPESCRIPT] | Archivo: `src/app/api/webhooks/stripe/route.ts`. Exportar `POST`. Lógica: 1) Verificar firma del webhook con `STRIPE_WEBHOOK_SECRET` usando `stripe.webhooks.constructEvent()`. 2) Si firma inválida → 400. 3) Router de eventos: switch por `event.type`. 4) Responder 200 inmediatamente después de validar — procesamiento async vía Inngest. **NO procesar síncrono** — emitir eventos Inngest para procesamiento background. Logging de cada evento recibido en activity_logs. | Webhook responde 200. Firma verificada. Eventos ruteados. |
| 03.7.5.2 | Handler: `checkout.session.completed` | [TYPESCRIPT] | Dentro del router de webhooks. Lógica: 1) Extraer customer_id, subscription_id, plan del session metadata. 2) Llamar `fn_process_subscription_change(user_id, plan, stripe_ids)` vía supabaseAdmin. 3) Plan puede ser: **weekly ($2.99), monthly ($9.99), protocol_100 ($29.99)** — NO yearly. 4) Actualizar subscription: status='active', plan=plan, stripe IDs. 5) Crear notificación. 6) Registrar payment en payments table. **Idempotencia:** Usar checkout session ID como idempotency_key. | Subscription activada. Plan correcto (3 opciones). Payment registrado. Idempotente. |
| 03.7.5.3 | Handler: `invoice.payment_succeeded` | [TYPESCRIPT] | Lógica: 1) Extraer invoice data. 2) Registrar en payments (status='completed'). 3) Si subscription estaba en 'limbo' → reactivar a 'active'. 4) Actualizar current_period_start/end. 5) Registrar en btc_transactions como metadata. | Payment registrado. Subscription reactivada si limbo. |
| 03.7.5.4 | Handler: `invoice.payment_failed` | [TYPESCRIPT] | Lógica: 1) Registrar intento fallido en payments (status='failed'). 2) Emitir evento Inngest `'app/subscription.payment-failed'`. 3) Si es 3er intento fallido → llamar `fn_handle_payment_failed(user_id)` que cambia subscription status a 'limbo'. 4) Crear notificación tipo 'death_warning' (re-usar para urgencia de pago). Stripe maneja reintentos automáticos — solo loguear cada intento. | Payment fallido registrado. Subscription a 'limbo' después de 3 fallos. Notificación creada. |
| 03.7.5.5 | Handler: `customer.subscription.deleted` | [TYPESCRIPT] | Lógica: 1) Subscription cancelada por Stripe (después de todos los reintentos fallidos o cancelación manual). 2) Llamar `fn_process_subscription_change(user_id, null, null)` con status='cancelled'. 3) Remover bonuses de subscripción del multiplicador BTC. 4) Recalcular daily_cap sin sub bonus. 5) Crear notificación. **Cap base sin sub: 2,000 BTC.** | Subscription cancelada. Bonuses removidos. Cap recalculado. |
| 03.7.5.6 | Crear utilidades Stripe | [TYPESCRIPT] | Archivo: `src/lib/stripe/client.ts`. Configurar cliente Stripe: `new Stripe(process.env.STRIPE_SECRET_KEY!)`. Archivo: `src/lib/stripe/plans.ts`. Mapeo de planes: `{ weekly: { priceId: STRIPE_PRICE_WEEKLY, amount: 299, btc_bonus: 0.05 }, monthly: { priceId: STRIPE_PRICE_MONTHLY, amount: 999, btc_bonus: 0.10 }, protocol_100: { priceId: STRIPE_PRICE_PROTOCOL_100, amount: 2999, btc_bonus: 0.20 } }` — **3 planes (NO 4, NO yearly)**. Bonuses son **ADITIVOS** al multiplicador BTC. Archivo: `src/lib/stripe/checkout.ts`. Funciones: `createCheckoutSession(userId, plan)`, `createCustomerPortalSession(userId)`. | Cliente configurado. 3 planes. NO existe plan 'yearly'. Bonuses aditivos. |

---

## 03.7.6 — SUPABASE AUTH INTEGRATION

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.7.6.1 | Crear middleware de auth para Next.js | [TYPESCRIPT] | Archivo: `src/middleware.ts`. Usar `@supabase/ssr` para manejar auth en Next.js App Router. Lógica: 1) Crear supabase server client con cookies. 2) Refrescar sesión si expirada. 3) Rutas protegidas: todo excepto `/auth/*`, `/api/webhooks/*`. 4) Rutas públicas: landing, auth callback, webhooks. 5) Si no autenticado → redirect a `/auth/login`. 6) Si autenticado pero onboarding_completed_at IS NULL → redirect a `/onboarding`. **NO usar Resend para emails — Supabase Auth nativo.** | Middleware protege rutas. Sesión refrescada. Redirect a login/onboarding funciona. |
| 03.7.6.2 | Crear auth callback handler | [TYPESCRIPT] | Archivo: `src/app/auth/callback/route.ts`. Exportar `GET`. Lógica: 1) Extraer `code` de URL params. 2) `supabase.auth.exchangeCodeForSession(code)`. 3) Si nuevo usuario → trigger `fn_handle_new_user` se ejecuta automáticamente vía trigger en auth.users. 4) Redirect a `/dashboard` o `/onboarding` según estado. **Auth flow: email magic link o email/password** — ambos via Supabase Auth nativo. | Callback procesa code. Sesión creada. Redirect correcto. |
| 03.7.6.3 | Crear server actions de auth | [TYPESCRIPT] | Archivo: `src/app/auth/actions.ts`. Server actions: 1) `signUp(email, password)` — usa supabase.auth.signUp(). Email de confirmación enviado por **Supabase Auth nativo**. 2) `signIn(email, password)` — usa supabase.auth.signInWithPassword(). 3) `signInWithMagicLink(email)` — usa supabase.auth.signInWithOtp(). 4) `signOut()` — usa supabase.auth.signOut(). 5) `resetPassword(email)` — usa supabase.auth.resetPasswordForEmail(). Todas retornan **Result Monad** `{ ok, value/error }`. Validación con Zod en inputs. | Auth actions funcionan. Emails enviados por Supabase. Result Monad en retornos. |

---

## 03.7.7 — SUPABASE STORAGE INTEGRATION

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.7.7.1 | Crear módulo de storage para avatares | [TYPESCRIPT] | Archivo: `src/lib/storage/avatars.ts`. Funciones (todas con Result Monad): 1) `uploadAvatar(userId, imageBuffer, format)` — Sube a **Supabase Storage** bucket 'avatars'. Path: `{user_id}/{timestamp}.{format}`. Usa supabaseAdmin (service_role) porque solo el worker sube avatares. 2) `getAvatarUrl(userId)` — Retorna URL pública del avatar más reciente. 3) `deleteOldAvatars(userId, keepCount=5)` — Mantiene solo los últimos 5 avatares. 4) `getAvatarHistory(userId)` — Lista todos los avatares del usuario con timestamps. **Storage: Supabase Storage (NO Cloudflare R2, NO S3).** | Upload funciona. URL pública accesible. Cleanup mantiene 5 últimos. |
| 03.7.7.2 | Crear módulo de storage para proofs | [TYPESCRIPT] | Archivo: `src/lib/storage/proofs.ts`. Funciones (Result Monad): 1) `uploadProof(userId, taskId, file)` — Sube a bucket 'proofs'. Path: `{user_id}/{task_id}/{filename}`. Usa supabase client (auth del usuario — RLS protege). Validar: max 5MB, solo image/* y video/mp4. 2) `getProofUrl(userId, taskId)` — Retorna signed URL (privado, expira en 1h). 3) `deleteProof(userId, taskId)` — Elimina proof del storage. | Upload con auth de usuario. RLS funciona. Signed URLs expiran. |
| 03.7.7.3 | Crear módulo de storage para assets | [TYPESCRIPT] | Archivo: `src/lib/storage/assets.ts`. Funciones: 1) `getAssetUrl(path)` — Retorna URL pública de asset estático. 2) `listCharacterAssets()` — Lista assets de los **6 personajes** base (EL_RASTAS a EL_LIC). 3) `listToolAssets()` — Lista assets de las **9 herramientas**. Bucket público, no necesita auth. Para deployment: subir assets iniciales vía Supabase CLI o dashboard. | URLs públicas accesibles. Assets de personajes y herramientas listados. |

---

## 03.7.8 — UPSTASH REDIS (SE MANTIENE PER USER OVERRIDE)

| ID | Título | Tipo | Detalle | Validación |  |
| --- | --- | --- | --- | --- | --- |
| 03.7.8.1 | Configurar cliente Upstash Redis | [TYPESCRIPT] | Archivo: `src/lib/redis/client.ts`. Usar `@upstash/redis`. Configurar: `const redis = new Redis({ url: process.env.UPSTASH_REDIS_REST_URL!, token: process.env.UPSTASH_REDIS_REST_TOKEN! })`. Exportar instancia singleton. **EXCEPCIÓN PER USER OVERRIDE: Upstash Redis SE MANTIENE aunque documentación v2.0.0 no lo mencione explícitamente.** Usado para: rate limiting, cache, BullMQ image queue. | Cliente conecta. Ping exitoso. Variables configuradas. |  |
| 03.7.8.2 | Crear módulo de rate limiting con Upstash | [TYPESCRIPT] | Archivo: `src/lib/redis/rate-limit.ts`. Usar `@upstash/ratelimit`. Limiters configurados: 1) `apiLimiter` — sliding window 100 req/min por usuario para API routes. 2) `geminiLimiter` — sliding window 60 req/min global para Gemini API. 3) `authLimiter` — fixed window 5 req/15min por IP para auth endpoints. 4) `taskCompleteLimiter` — sliding window 20 req/min por usuario para completar tareas. Función helper: `checkRateLimit(limiter, identifier)` retorna Result Monad `{ ok: true, value: { remaining, reset } } | { ok: false, error: { code: 'RATE_LIMITED', retryAfter } }`. | Rate limiters funcionan. Requests excedentes rechazados con 429. |
| 03.7.8.3 | Crear módulo de cache con Upstash | [TYPESCRIPT] | Archivo: `src/lib/redis/cache.ts`. Funciones: 1) `cacheUserState(userId, state, ttl=300)` — Cache del estado completo del usuario (fn_get_user_full_state) por 5 min. Key: `user:${userId}:state`. 2) `getCachedUserState(userId)` — Obtener estado cacheado. 3) `invalidateUserCache(userId)` — Invalidar cuando hay cambios (task complete, purchase, etc). 4) `cacheStoreCatalog(catalog, ttl=3600)` — Cache del catálogo de tienda por 1h. Key: `store:catalog`. 5) `cacheLeaderboard(data, ttl=600)` — Cache de leaderboard por 10 min. Key: `leaderboard:global`. Pattern: **cache-aside** con stale-while-revalidate. | Cache funciona. TTLs correctos. Invalidación limpia cache. |  |
| 03.7.8.4 | Configurar BullMQ con Upstash Redis | [TYPESCRIPT] | Archivo: `src/lib/redis/queue.ts`. Usar `bullmq` con conexión a **Upstash Redis** via `UPSTASH_REDIS_URL` (redis:// protocol para BullMQ, NO REST). Queue: `image-generation`. Configurar: `const imageQueue = new Queue('image-generation', { connection: { url: process.env.UPSTASH_REDIS_URL } })`. Funciones: 1) `addImageJob(userId, queueId, priority)` — Agrega job con priority (1-10, 1=highest). 2) `getJobStatus(jobId)` — Obtener status del job. Jobs contienen: user_id, queue_id (de image_generation_queue), vectors_snapshot, equipped_items, base_avatar_id. **Nota:** BullMQ worker procesa jobs y llama a Gemini. Alternativa viable: usar solo Inngest para la queue (inngest.send → function con throttle). Implementar ambos y el agente ejecutor decidirá cuál usar. | Queue creada. Jobs se agregan con priority. Connection a Upstash funciona. |  |
| 03.7.8.5 | Crear BullMQ worker para image generation | [TYPESCRIPT] | Archivo: `src/lib/redis/worker.ts`. Worker BullMQ que procesa jobs de la queue `image-generation`. Lógica por job: 1) Obtener datos del image_generation_queue. 2) Construir prompt (fn_build_image_prompt). 3) Check rate limit Gemini vía `geminiLimiter`. 4) Si rate limited → throw error (BullMQ reintenta automáticamente). 5) Llamar Gemini para generar imagen. 6) Procesar imagen (resize, compress). 7) Subir a **Supabase Storage** bucket 'avatars'. 8) Actualizar image_generation_queue: status='completed', result_url. 9) Actualizar profiles avatar_url. Retry: 3 attempts con exponential backoff. Concurrency: 2 (procesar 2 imágenes simultáneas). | Worker procesa jobs. Imágenes generadas y subidas. Queue status actualizado. Retries funcionan. |  |

---

## 03.7.9 — INNGEST + EXTERNAL SERVICES WIRING

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.7.9.1 | Crear barrel export de funciones Inngest | [TYPESCRIPT] | Archivo: `src/lib/inngest/functions/index.ts`. Exportar array `allFunctions` con TODAS las funciones Inngest: judgementNightCron, judgementProcessBatch, judgementProcessUser, dailyVectorDecay, dailyBtcReset, cleanupCron, trialExpirationCheck, hibernationCheck, generateDailyTasks, enrichTaskWithAI, processAvatarDeath, generateAvatarImage. Total: **12 funciones Inngest**. Importadas en el API route `/api/inngest`. | 12 funciones exportadas. API route las registra todas. Inngest Dev Server las muestra. |
| 03.7.9.2 | Crear barrel export de módulos Redis | [TYPESCRIPT] | Archivo: `src/lib/redis/index.ts`. Exportar: redis (client), rateLimiters (apiLimiter, geminiLimiter, authLimiter, taskCompleteLimiter), cache (cacheUserState, getCachedUserState, invalidateUserCache, cacheStoreCatalog, cacheLeaderboard), queue (imageQueue, addImageJob, getJobStatus). | Imports limpios desde `@/lib/redis`. |
| 03.7.9.3 | Crear barrel export de módulos Storage | [TYPESCRIPT] | Archivo: `src/lib/storage/index.ts`. Exportar: avatars (uploadAvatar, getAvatarUrl, deleteOldAvatars, getAvatarHistory), proofs (uploadProof, getProofUrl, deleteProof), assets (getAssetUrl, listCharacterAssets, listToolAssets). | Imports limpios desde `@/lib/storage`. |
| 03.7.9.4 | Crear barrel export de módulos Gemini | [TYPESCRIPT] | Archivo: `src/lib/gemini/index.ts`. Exportar: client (generateText, generateImage), prompts (buildAvatarPrompt, buildTaskEnrichmentPrompt), imageProcessing (processGeneratedImage, uploadToSupabaseStorage, deleteOldAvatars), rateLimiter (checkGeminiRateLimit). | Imports limpios desde `@/lib/gemini`. |
| 03.7.9.5 | Crear barrel export de módulos Stripe | [TYPESCRIPT] | Archivo: `src/lib/stripe/index.ts`. Exportar: client (stripe), plans (PLAN_CONFIG, getPlanByPriceId), checkout (createCheckoutSession, createCustomerPortalSession). **3 planes:** weekly, monthly, protocol_100. | Imports limpios desde `@/lib/stripe`. |

---

## 03.7.10 — VARIABLES DE ENTORNO Y DOCUMENTACIÓN

| ID | Título | Tipo | Detalle | Validación |
| --- | --- | --- | --- | --- |
| 03.7.10.1 | Crear `.env.local.example` definitivo | [CONFIG] | Template completo de variables de entorno. **Supabase:** NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY. **Stripe:** STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, STRIPE_PRICE_WEEKLY, STRIPE_PRICE_MONTHLY, STRIPE_PRICE_PROTOCOL_100 — **3 prices (NO yearly).** **Upstash (SE MANTIENE):** UPSTASH_REDIS_REST_URL, UPSTASH_REDIS_REST_TOKEN, UPSTASH_REDIS_URL. **Gemini:** GOOGLE_AI_API_KEY — **Solo Gemini 2.5 Flash.** **Inngest:** INNGEST_EVENT_KEY, INNGEST_SIGNING_KEY. **App:** NEXT_PUBLIC_APP_URL. **PROHIBIDO incluir:** FAL_AI_KEY, RESEND_API_KEY, CLOUDFLARE_R2_*, STRIPE_PRICE_YEARLY. Total: **14 variables.** | Archivo existe. 14 variables. NO contiene keys prohibidas. |
| 03.7.10.2 | Crear validation de env vars en runtime | [TYPESCRIPT] | Archivo: `src/lib/env.ts`. Usar Zod para validar TODAS las variables de entorno al iniciar la app. Schema: `envSchema = z.object({ NEXT_PUBLIC_SUPABASE_URL: z.string().url(), ... })`. Llamar `envSchema.parse(process.env)` en `src/lib/env.ts` e importar resultado tipado. Si falta alguna variable → error descriptivo con nombre de la variable faltante. **Agrupar por servicio** para mejor DX: supabase (3), stripe (5), upstash (3), gemini (1), inngest (2), app (1). | App no inicia sin variables requeridas. Error descriptivo. Tipos inferidos correctamente. |

---